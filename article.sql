/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50505
Source Host           : localhost:3306
Source Database       : article

Target Server Type    : MYSQL
Target Server Version : 50505
File Encoding         : 65001

Date: 2019-12-15 16:00:19
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for card_list
-- ----------------------------
DROP TABLE IF EXISTS `card_list`;
CREATE TABLE `card_list` (
  `id` varchar(255) NOT NULL,
  `title` varchar(255) DEFAULT NULL,
  `message` longtext DEFAULT NULL,
  `image` varchar(255) DEFAULT NULL,
  `video` varchar(255) DEFAULT NULL,
  `user_id` varchar(255) NOT NULL,
  `likes` int(255) DEFAULT 0,
  `kind` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`,`user_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of card_list
-- ----------------------------
INSERT INTO `card_list` VALUES ('1574218871', 'web开发的一些小提示', '<p>一些注意\n页面编码规范\n1.1. 统一使用 UTF-8 编码,用@charset “utf-8&quot;指定页面编码。\n1.2. 全局字体设置：\nwindows 7系统：微软雅黑 Arial；\nwindows XP及以下：新宋体，宋体，Arial\nMAC默认字体：Helvetica Neue和Helvetica Hiragino Sans GB。\nfont-family:“Microsoft Yahei”,“Hiragino Sans GB”,“Helvetica Neue”,Helvetica,tahoma,arial,Verdana,sans-serif,“WenQuanYi Micro Hei”,”\\5B8B\\4F53&quot;;\n1.3. 中文字体使用编码转换\n1.4. 推荐使用web安全色\n属性写在一行内，属性之间、属性名和值之间以及属性与“{}”之间应减少空格，去掉最后一个“;”，例如：.class{width:200px;height:100px}</p>\n<p>属性的书写顺序：\n3.1. 按照元素模型由外及内，由整体到细节书写，大致分为五组：</p>\n<p>位置：position,left,right,float\n盒模型属性：display,margin,padding,width,height\n边框与背景：border,background\n段落与文本：line-height,text-indent,font,color,text-decoration,…\n其他属性：overflow,cursor,visibility,…\nscss\n3.2. 针对特殊浏览器的属性，应写在标准属性之前，例如：-webkit-box-shadow:;-moz-box-shadow:;box-shaow:;</p>\n<p>带有前缀的属性，单独一行，通过缩进，让每个属性的值垂直对齐，方便编辑维护。</p>\n<p>谨慎添加新的选择符规则，尤其不可滥用 id，尽可能继承和复用已有样式</p>\n<p>选择符、属性、值均用小写（格式的颜色值除外），缩写的选择符名称须说明缩写前的全称，例如 .cl -&gt; Clearfix</p>\n<p>避免使用各种CSS Hack。</p>\n<p>勿使用冗余低效的 CSS 写法，例如：ul li a span{… }</p>\n<p>慎用 !important</p>\n<p>建议使用具有语义化的classname或id.</p>\n<p>11.避免使用兼容性不好的使用滤镜 .</p>\n<p>12.开发过程中的未定事项，须用 [!] 标出，以便于后续讨论整理。</p>\n<p>13.注释格式，统一使用双斜杠加*。</p>\n<p>14.上下模块之间的间距统一使用下一个模块的margin-top来实现，好处是：如果没有下一个模块也不会多出一段空隙。</p>\n<p>15.hover，selected，disabled，current等具有特定意义的请勿直接占用。</p>\n<p>16.:link :visited :hover :active书写顺序 L-V-H-A，速记：LoVe（喜欢）HAte（讨厌）。</p>\n<p>17.不要使用 @import</p>\n<p>中文字体css编码转换\n微软雅黑   \\5FAE\\8F6F\\96C5\\9ED1  或 Microsoft YaHei\n黑体       \\9ED1\\4F53\n新宋体     \\65b0\\5b8b\\4f53\n宋体       \\5b8b\\4f53\nlsl\ncss命名中英文对照\ncurrent 当前    hover 悬停    selected 挑选   disabled 禁用   focus 得到焦点<br>\nblur 失去焦点   checked 勾选    success 成功    error 出错\nheader(hd) 头部   content(cnt) 内容   title(tit) 标题   item 项目（条）<br>\ncell 单元   image/pic(img) 图片   text(txt) 文字    top 顶部    scrubber 时序菜单\nnav 导航    mainbav 主导航   subnav 子导航    topnav 顶部导航<br>\nbreadcrumb 面包屑导航  flink 友情链接    footer 尾    copyright 版权\nmenu 菜单   submenu 子菜单   dropdown 下拉菜单\nsearchBar 搜索条   search 搜索条    searchTxt 搜索框<br>\nsearchBtn 搜索按钮    search_key 搜索词\nmember 会员   ucenter 用户中心    loginBar 登陆条<br>\nlogin 登录    loginBtn 登录按钮   regsiter 注册按钮<br>\nbtn-regsiter注册按钮    name 用户名    password 密码<br>\nnickname 昵称   mobilephone/mobile 手机<br>\ntelephone/tel 电话   defaultavatar 默认头像\nhot 热点    news 新闻   banner/AD 广告    download 下载\ncontent 内容    title 标题    summary 摘要    time 时间\nshare 分享    digg 顶    like 喜欢\nlist 列表   pList 图片列表    tList 文字列表    tpList 图文列表\ntable 表格    row 行   column 列    gutter 间隔   viewport 视口\ntab 标签    tags 标签   scroll 滚动\nsidebar 侧边栏   column 栏目   section 区块    msg 提示信息<br>\nstatus 状态   vote 投票   tips 小技巧    guild 指南    note 注释\nicon- 图标    btn- 按钮\ngoods 商品    goodsList 商品列表    goodsDetail 商品详情    goodsInfo 商品信息\ntuan 团购   tuanList 团购列表   tuanDetail  团购详情    tuanInfo 团购信息\ntransition 动画   shadow 阴影   fade 淡入淡出   flip 翻页效<br>\nslide 滑动    slideup 上滑动   slidedown 下滑动   turn 翻页\nhorizontal 水平   vertical 垂直   collapsible 折叠    corners 拐角<br>\nflow 流    reverse 反向    pop 弹窗\ncount 总数/计数   plus 加号/正   minus 减号/负    controlgroup 控制组\nstylus\n页面命名\ndefault/index.html    首页\n404.html              404错误页\nprint.html            打印页\nheader.html           页头\nfooter.html           页脚\nsitemap.html          网站地图\npassport.html         通行证\nrank.html             排行榜\nroll.html             滚动新闻\nsolution.html         解决方案\njoinus.html           加入我们\npartner.html          合作伙伴\nservice.html          服务\naboutus.html          关于我们\ncontact.html          联系我们\ncompany.html          公司介绍\norganization.html     组织结构\nculture.html          企业文化\nstrategy.html         发展策略\nhonor.html            公司荣誉\naptitudes.html        企业资质\nevents.html           大事记\nbusiness.html         商务合作\ncontract.html         服务条款\nprivacy.html          隐私声明\nCSR.html              企业社会责任\nnews-开头.html         新闻相关\narticle-开头.html      资讯相关\npicture-开头.html      图片相关\nphoto-开头.html        相册相关\nproduct-开头.html      产品相关\ngoods-开头.html        商品相关\nsystem-开头.html       系统相关\ntag-开头.html          tag相关\nbrand-开头.html        品牌相关\nhelp-开头.html         帮助相关\nmember-开头.html       会员相关\nsearch-开头.html       搜索相关\nstylus\n文件命名\nadmin     后台管理\napp       应用\narticle   资讯\ncommon    公共\nconfig    配置\ndata      数据\ndigg      顶\nen-us     英文\nextend    延伸\ninstall   安装\nLang      语言包\nLib       库\nmall      商城\npicture   组图\nproduct   商品\nsearch    搜索\nsection   区块\nshop      商店\nstatic    静态\nsystem    系统\ntemplates 模版\ntuan      团购\nucenter   用户中心\nupload    上传\nvideo     视频\nvote      投票\nzh_tw     繁体中文\nzh-cn     简体中文\nrouteros\nHTTP 状态消息\n当浏览器从 web 服务器请求服务时，可能会发生错误。</p>\n<p>从而有可能会返回下面的一系列状态消息：</p>\n<p>1xx\n100 Continue 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。\n101 Switching Protocols 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</p>\n<p>2xx\n200 OK 请求成功（其后是对GET和POST请求的应答文档。）\n201 Created 请求被创建完成，同时新的资源被创建。\n202 Accepted 供处理的请求已被接受，但是处理未完成。\n203 Non-authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。\n204 No Content 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。\n205 Reset Content 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。\n206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它。</p>\n<p>3xx\n300 Multiple Choices 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。\n301 Moved Permanently 所请求的页面已经转移至新的url。\n302 Found 所请求的页面已经临时转移至新的url。\n303 See Other 所请求的页面可在别的url下被找到。\n304 Not Modified 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。\n305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取。\n306 Unused 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。\n307 Temporary Redirect 被请求的页面已经临时移至新的url。</p>\n<p>4xx\n400 Bad Request 服务器未能理解请求。\n401 Unauthorized 被请求的页面需要用户名和密码。\n402 Payment Required 此代码尚无法使用。\n403 Forbidden 对被请求页面的访问被禁止。\n404 Not Found 服务器无法找到被请求的页面。\n405 Method Not Allowed 请求中指定的方法不被允许。\n406 Not Acceptable 服务器生成的响应无法被客户端所接受。\n407 Proxy Authentication Required 用户必须首先使用代理服务器进行验证，这样请求才会被处理。\n408 Request Timeout 请求超出了服务器的等待时间。\n409 Conflict 由于冲突，请求无法被完成。\n410 Gone 被请求的页面不可用。\n411 Length Required “Content-Length” 未被定义。如果无此内容，服务器不会接受请求。\n412 Precondition Failed 请求中的前提条件被服务器评估为失败。\n413 Request Entity Too Large 由于所请求的实体的太大，服务器不会接受请求。\n414 Request-url Too Long 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。\n415 Unsupported Media Type 由于媒介类型不被支持，服务器不会接受请求。\n416 服务器不能满足客户在请求中指定的Range头。\n417 Expectation Failed</p>\n<p>5xx\n500 Internal Server Error 请求未完成。服务器遇到不可预知的情况。\n501 Not Implemented 请求未完成。服务器不支持所请求的功能。\n502 Bad Gateway 请求未完成。服务器从上游服务器收到一个无效的响应。\n503 Service Unavailable 请求未完成。服务器临时过载或当机。\n504 Gateway Timeout 网关超时。\n505 HTTP Version Not Supported 服务器不支持请求中指明的HTTP协议版本</p>\n', 'images/1_codingps_1566021498.jpg', '', '8', '5', null);
INSERT INTO `card_list` VALUES ('1574218944', 'git使用', '<p>安装\nwindows git-for-windows\nubuntu sudo apt-get install git\n配置信息\n必须配置\n// 配置用户名\ngit config --global <a href=\"http://user.name\">user.name</a> “zxysilent”\n//配置用户邮箱\ngit config --global user.email “<a href=\"mailto:zxysilent@outlook.com\">zxysilent@outlook.com</a>”\nstylus\n–global 表示你这台机器上所有的Git仓库都会使用这个配置</p>\n<p>其他配置\n$ git config --list\n比如git config core.ignorecase false设置大小写敏感</p>\n<p>关系图\nalt\nWorkspace:工作区\nIndex/Stage:暂存区\nRepository:本地仓库\nRemote:远程仓库</p>\n<p>基本Git使用\n版本跟踪\n选择一个文件夹\nalt\n使用git init命令把这个目录变成Git可以管理的仓库\ngit init<br>\nInitialized empty Git repository in D:/App/Github/zxyslt/.git/\n当前目录下会自动创建一个隐藏的.git的目录，这个目录是Git来跟踪管理版本库的，不要自己修改这个目录里面的文件，因为修改了文件可能产生不可预知的问题! 比如把Git仓库给破坏了。</p>\n<p>用vscode or notepad++ 不是Windows自带的notepad 添加测试文件a.txt写上一点数据aaaaaa</p>\n<p>用git add a.txt把文件a.txt添加到暂存区(Index/Stage)</p>\n<p>$ git add a.txt\n命令行中执行命令后没有提示信息一般代表成功</p>\n<p>用git commit -m &quot;备注信息&quot;把暂存区的内容添加到本地仓库(Repository)</p>\n<p>$ git commit -m “write aaaaaa”\n[master (root-commit) caac3d8] write aaaaaa\n1 file changed, 1 insertion(+)\ncreate mode 100644 a.txt\nsql\n注释为中文可能发生意外(Please refer to Baidu!)</p>\n<p>用git status查看工作区的状态(Workspace)\n$ git status\nOn branch master\nnothing to commit, working tree clean\n修改文件a.txt添加一行bbbbbb 保存\n用git status查看工作区的状态\n$ git status\nOn branch master\nChanges not staged for commit:\n(use “git add <file>…” to update what will be committed)\n(use “git checkout – <file>…” to discard changes in working directory)\nmodified:   a.txt\nno changes added to commit (use “git add” and/or “git commit -a”)\nsql\n用 git diff or git diff a.txt查看文件变化\n$ git diff a.txt\ndiff --git a/a.txt b/a.txt\nindex 90b4516…85553e8 100644\n— a/a.txt\n+++ b/a.txt\n@@ -1 +1,2 @@\naaaaaa\n+bbbbbb\nstylus\n用git add a.txt把文件a.txt添加到暂存区然后用git status查看工作区的状态\n$ git status\nOn branch master\nChanges to be committed:\n(use “git reset HEAD <file>…” to unstage)\nmodified:   a.txt\nstylus\n用git commit -m &quot;备注信息&quot;把暂存区的内容添加到本地仓库\n$ git commit -m “append bbbbbb”\n[master 1baf46d] append bbbbbb\n1 file changed, 1 insertion(+)\n用git log查看提交记录\n$ git log\ncommit 1baf46dea014d993843137d3bf0aa56fe448699a (HEAD -&gt; master)\nAuthor: zxysilent <a href=\"mailto:zxysilent@foxmail.com\">zxysilent@foxmail.com</a>\nDate:   Fri Nov 10 21:18:13 2017 +0800\nappend bbbbbb\ncommit caac3d8a845500c95f70499b40710826fcd644af\nAuthor: zxysilent <a href=\"mailto:zxysilent@foxmail.com\">zxysilent@foxmail.com</a>\nDate:   Fri Nov 10 21:00:34 2017 +0800\nwrite aaaaaa\nangelscript\n用git log --pretty=oneline查看简要提交记录\n$ git log --pretty=oneline\n1baf46dea014d993843137d3bf0aa56fe448699a (HEAD -&gt; master) append bbbbbb\ncaac3d8a845500c95f70499b40710826fcd644af write aaaaaa\n每一次提交就是一个版本 commit_id</p>\n<p>小结\ngit init 初始化一个仓库\ngit add file 添加文件到暂存区\ngit commit -m “注释信息” 把暂存区文件添加到仓库(一次提交为一个版本)\ngit status 查看工作区状态信息\ngit diff or git diff <file> 查看文件变化信息\ngit log查看提交记录\ngit log --pretty=oneline查看简要提交记录\n后悔药\n修改文件a.txt添加一行cccccc保存\n用git add a.txt添加到暂存区\n用git commit -m &quot;append cccccc&quot;提交到版本库\n用git log查看版本记录\n$ git log\ncommit cccb318a93f00cd0dd092c8385354e0d34f3d226 (HEAD -&gt; master)\nAuthor: zxysilent <a href=\"mailto:zxysilent@foxmail.com\">zxysilent@foxmail.com</a>\nDate:   Fri Nov 10 21:50:35 2017 +0800\nappend cccccc\ncommit 1baf46dea014d993843137d3bf0aa56fe448699a\nAuthor: zxysilent <a href=\"mailto:zxysilent@foxmail.com\">zxysilent@foxmail.com</a>\nDate:   Fri Nov 10 21:18:13 2017 +0800\nappend bbbbbb\ncommit caac3d8a845500c95f70499b40710826fcd644af\nAuthor: zxysilent <a href=\"mailto:zxysilent@foxmail.com\">zxysilent@foxmail.com</a>\nDate:   Fri Nov 10 21:00:34 2017 +0800\nwrite aaaaaa\nangelscript\n用git reset --hard HEAD^ 把当前的版本回退到上一个版本(with two dashes)\n$ git reset --hard HEAD^\nHEAD is now at 1baf46d append bbbbbb\n要回退到上上个版本只需把HEAD<sup>改成HEAD</sup>^以此类推。\n如果要回退到前100个版本的话，可以使用git reset –hard HEAD~100即可\n更多信息Please refer to Baidu!</p>\n<p>用git reset --hard commit_id 把当前的版本切换到指定版本</p>\n<p>$ git reset --hard caac3d8\nHEAD is now at caac3d8 write aaaaaa\n一般输入前7个就可以了</p>\n<p>用git log查看版本记录</p>\n<p>$ git log\ncommit caac3d8a845500c95f70499b40710826fcd644af\nAuthor: zxysilent <a href=\"mailto:zxysilent@foxmail.com\">zxysilent@foxmail.com</a>\nDate:   Fri Nov 10 21:00:34 2017 +0800\nwrite aaaaaa\nangelscript\n其他提交信息不见了，不见了</p>\n<p>用git reflog查看每次操作版本的记录\n$ git reflog\ncaac3d8 (HEAD -&gt; master) HEAD@{0}: reset: moving to caac3d8\n1baf46d HEAD@{1}: reset: moving to HEAD^\ncccb318 HEAD@{2}: commit: append cccccc\n1baf46d HEAD@{3}: commit: append bbbbbb\ncaac3d8 (HEAD -&gt; master) HEAD@{4}: commit (initial): write aaaaaa\nangelscript\n看到了熟悉的版本号又可以用git reset --hard commit_id切换到指定版本</p>\n<p>小结\ngit log 查看提交记录\ngit reset --hard HEAD^ 把当前的版本回退到上一个版本\ngit reflog 查看每次操作版本的记录\ngit reset --hard commit_id 把当前的版本切换到指定版本\n撤销修改\n情形A(工作区)\n修改文件a.txt添加一行dddeee保存并用git status查看工作区信息\n$ git status\nOn branch master\nChanges not staged for commit:\n(use “git add <file>…” to update what will be committed)\n(use “git checkout – <file>…” to discard changes in working directory)\nmodified:   a.txt\nno changes added to commit (use “git add” and/or “git commit -a”)\nsql\n突然意识到 天啦不是应该dddddd\n此处有重点 (use “git checkout – …” to discard changes in working directory)\n用git checkout – a.txt 丢弃工作区\n$ git checkout – a.txt\n查看文件发现dddeee消失了\n注意这里有两种情况：\n一种是a.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n一种是a.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n总之，git checkout – <file>就是让这个文件回到最近一次git commit或git add时的状态。</p>\n<p>情形B(暂存区)\n修改文件a.txt添加一行fffggg保存然后用git add a.txt添加到暂存区再用git status查看工作区信息\n$ git status\nOn branch master\nChanges to be committed:\n(use “git reset HEAD <file>…” to unstage)\nmodified:   a.txt\nstylus\n此处又有重点 (use “git reset HEAD …” to unstage)\nIndex/Stage:暂存区\n要多看提示信息</p>\n<p>用git reset HEAD a.txt 暂存区的修改撤销掉\n$ git reset head a.txt\nUnstaged changes after reset:\nM       a.txt\n用git status查看工作区信息\n$ git status\nOn branch master\nChanges not staged for commit:\n(use “git add <file>…” to update what will be committed)\n(use “git checkout – <file>…” to discard changes in working directory)\nmodified:   a.txt\nno changes added to commit (use “git add” and/or “git commit -a”)\nsql\n现在暂存区是干净的，工作区有修改\ngit checkout – <file> 丢弃工作区</p>\n<p>情形C\n版本库？\ngit reset --hard commit_id为所欲为</p>\n<p>小结\n工作区修改未提交 git checkout – <file> 工作区撤销到版本库一样\n工作区修改已经提交 git checkout – <file> 工作区撤销到暂存区一样\n工作区修改已经提交 git reset HEAD a.txt` 暂存区的修改撤销掉\ngit reset --hard commit_id 把当前的版本切换到指定版本\n删除文件\n添加t.txt文件写上一点数据tttttt添加到暂存区(git add t.txt)并且提交到版本库(git commit -m “备注信息”)\ngit add t.txt\n$ git commit -m “add t.txt”\n[master 2d0d9fa] add t.txt\n1 file changed, 1 insertion(+)\ncreate mode 100644 t.txt\nsql\n删除t.txt并用git status查看工作区信息</p>\n<p>$ git status\nOn branch master\nChanges not staged for commit:\n(use “git add/rm <file>…” to update what will be committed)\n(use “git checkout – <file>…” to discard changes in working directory)\ndeleted:    t.txt\nno changes added to commit (use “git add” and/or “git commit -a”)\nsql\n此处有重点</p>\n<p>(use “git add/rm …” to update what will be committed)\n(use “git checkout – …” to discard changes in working directory)</p>\n<p>用git checkout – <file> 撤销删除\n$ git checkout – t.txt\n用 git add/rm <file> 并用 git commit -m “备注信息” 从版本库中删除\n$ git rm t.txt\nrm ‘t.txt’\n$ git commit -m “delete t.txt”\n[master 3b3b9f2] delete t.txt\n1 file changed, 1 deletion(-)\ndelete mode 100644 t.txt\nsql\n小结\ngit rm <file> and git commit -m &quot;备注信息&quot;从版本库删除\n误删除 git checkout – <file> 撤销删除</p>\n', 'images/4.jpg', '', '8', '6', null);
INSERT INTO `card_list` VALUES ('1574238492', '使用 oracle 数据库', '<p>连接\nsqlplus /nolog 进入sqlplus命令行</p>\n<p>在SQL Plus中登录Oracle的用户的语法格式：\n{<username>[/<password>][@&lt;connect_identifier&gt;] | / }[AS { SYSDBA | SYSOPER }]</p>\n<p>username/password：指定数据库账户用户名，口令</p>\n<p>connect_identifier：数据库连接的连接标识符（服务器名）。如果没有连接标识符，SQL Plus将连接到默认的数据库。</p>\n<p>SYSDBA、SYSOPER选项是数据库管理员权限（SYSDBA:数据库管理员的权限；SYSOPER：数据库操作员的权限）</p>\n<p>启用scott用户\n给scott用户解锁【语法格式】（默认的scott用户是锁定的）：alter user username account unlock</p>\n<p>例：alter user scott account unlock</p>\n<p>赋予权限\n口令GRANT power TO uname;\n连接权限 grant connect to SCOTT ;\n一般权限（基本操作） grant rescore to SCOTT ;\n修改密码\n修改用户口令 格式为：alter user uname identified by password</p>\n<p>以system 为例，密码修改为 123456. 可输入 alter user system identified by 123456;</p>\n', 'images/5b9b229074afb.jpg', '', '8', '51', null);
INSERT INTO `card_list` VALUES ('1574322585', 'goweb-035-golang-接口', '接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。', '', 'media/5505888-1-16.mp4', '8', '11', 'Python');
INSERT INTO `card_list` VALUES ('1574322596', '关于Python web开发', '<p><u>1.Django</u>\nDjango是一个开源的Web应用框架，由Python写成，支持许多数据库引擎，可以让Web开发变得迅速和可扩展，并会不断的版本更新以匹配Python最新版本，如果是新手程序员，可以从这个框架入手。</p>\n<p><u>2.Flask</u>\nFlask是一个轻量级的Web应用框架, 使用Python编写。基于 WerkzeugWSGI工具箱和 Jinja2模板引擎。使用 BSD 授权。\nFlask也被称为 “microframework” ，因为它使用简单的核心，用 extension 增加其他功能。Flask没有默认使用的数据库、窗体验证工具。然而，Flask保留了扩增的弹性，可以用Flask-extension加入这些功 能：ORM、窗体验证工具、文件上传、各种开放式身份验证技术。</p>\n<p><u>3.Web2py</u>\nWeb2py是一个用Python语言编写的免费的开源Web框架，旨在敏捷快速的开发Web应用，具有快速、可扩展、安全以及可移植的数据库驱动的应用，遵循LGPLv3开源协议。\nWeb2py提供一站式的解决方案，整个开发过程都可以在浏览器上进行，提供了Web版的在线开发，HTML模版编写，静态文件的上传，数据库的编写的功能。其它的还有日志功能，以及一个自动化的admin接口。</p>\n<p><u>4.Tornado</u>\nTornado即是一个Web server(对此本文不作详述)，同时又是一个类web.py的micro-framework，作为框架Tornado的思想主要来源于Web .py。</p>\n<p><u>5.CherryPy</u>\nCherryPy是一种用于Python的、简单而非常有用的Web框架，其主要作用是以尽可能少的操作将Web服务器与Python代码连接，其功能包括内置的分析功能、灵活的插件系统以及一次运行多个HTTP服务器的功能，可与运行在最新版本的Python、Jython、Android上。</p>\n', 'images/50dad1678fe2609d868ce4fb71bf1ee4.jpg', '', '8', '1', null);
INSERT INTO `card_list` VALUES ('1574328704', 'Python爬虫小白教程', '安装Requests库\nRequests库是Python中抓取网页的一个开源库，功能极为强大。我们可以通过pip安装，如果使用Anaconda的话也可以使用conda安装。', '', 'media/1_design407_1574320891.jpg', '8', '1', null);
INSERT INTO `card_list` VALUES ('1574586532', '中国知网爬虫', '，在知网上，搜索论文的方式有很多种，但是对于专业人士来说，一般都会使用高级检索，因为直接去查找作者的话，容易查找到很多重名作者，所以我们本次的爬虫也是使用了高级检索(泛称)的爬虫，再具体就是专业检索，有助于我们唯一定位到作者。', '', 'media/big_buck_bunny.mp4', '8', '0', 'Python');
INSERT INTO `card_list` VALUES ('1575371685', 'goweb-033-golang-函数', '<p>函数声明\n函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。\n形式参数列表描述了函数的参数名以及参数类型。\n返回值列表描述了函数返回值的变量名以及类型。\n若函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。\n若函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。\nfunc name(parameter-list) (result-list) {\nbody\n}\nfunc add(a int ,b int) int{\nreturn a+b\n}\n// 命名返回值\nfunc min(a, b int) (min int) {\nif a &gt; b {\nmin = b\n} else {\nmin = a\n}\nreturn\n}\ngo\n一组形参或返回值有相同的类型，不必为每个形参都写出参数类型。</p>\n<p>func f(i, j, k int, s, t string)                 { /* … <em>/ }\nfunc f(i int, j int, k int,  s string, t string) { /</em> … */ }\n函数的类型被称为函数的签名☝️如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。\n函数调用都必须按照声明顺序为所有参数提供实参。\n实参通过值的方式传递，对形参进行修改不会影响实参。\n实参包括引用类型，如指针，slice、map等类型，实参可能会由于函数的间接引用被修改。\n没有函数体的函数声明，这表示该函数不是以Go实现的，只有函数签名。</p>\n<p>package math\nfunc Sin(x float64) float //implemented in assembly language\n递归\n函数可以是递归的，函数可以直接或间接的调用自身。</p>\n<p>func fib(n int) int {\nif n &lt;= 1 {\nreturn 1\n}\nreturn fib(n-1) + fib(n-2)\n}\nfunc main() {\nfor i := 0; i &lt; 10; i++ {\nfmt.Printf(&quot;\\t%d&quot;, fib(i))\n}\n}\ngo\n多返回值\n在Go语言中，一个函数可以返回多个值。\n标准库中的许多函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。\nfunc f(a, b int) (max, min int) {\nif a &gt; b {\nmax = a\nmin = b\n} else {\nmax = b\nmin = a\n}\nreturn\n}\nfunc main() {\nmax, min := f(10, 100)\nfmt.Println(max, min)\n}\ngo\nhttp请求</p>\n<p>package main\nimport (\n“fmt”\n“net/http”\n)\nfunc main() {\n// resp 服务器响应内容\n// err http请求出错时候的信息\nresp, err := http.Get(<code>https://blog.zxysilent.com</code>)\nif err != nil { // 不等于nil 表示有错误\npanic(err) //抛出异常\n}\n// 准备容器\nbuf := make([]byte, 1024<em>10) //1kb</em>10\n// 读取响应内容到 数据容器中\nl, err := resp.Body.Read(buf) //读取长度和错误\nfmt.Println(l, err)\n// 字节转换为字符串\nfmt.Println(string(buf[:l]))\n}\ngo\n函数值\n在Go语言中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。</p>\n<p>func add(a, b int) int {\nreturn a + b\n}\nfunc fn() func(int, int) int {\n// 产生了一个不知名的函数\n// 匿名函数\nreturn func(a, b int) int {\nreturn a + b\n}\n}\nfunc main() {\nf := add\nfmt.Println(f(10, 20))\n//插播内容\nfunc() {\nfmt.Println(“匿名函数自执行”)\n}()\nfmt.Println(fn()(100, 200))\n}\ngo\n函数类型的零值是nil，调用值为nil的函数值会引起panic。</p>\n<pre><code>var fn func(int) int\nfn(10) // 此处f的值为nil, 会引起panic错误\n</code></pre>\n<p>函数值可以与nil比较。</p>\n<pre><code>var fn func(int) int\nif fn != nil {\n    fn(10)\n}\n</code></pre>\n<p>go\n✍️函数值之间是不可比较的，也不能用函数值作为map的key。</p>\n<p>可变参数\n参数数量可变的函数称为可变参数函数。 fmt.Printf首先接收一个必备的参数，之后接收任意个数的后续参数。\n在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号…，这表示该函数会接收任意数量的该类型参数。\nfunc sum(vals…int) int {\ntotal := 0\nfor _, val := range vals {\ntotal += val\n}\nreturn total\n}\ngo\nsum函数返回任意个int型参数的和。在函数体中，vals被看作是类型为[] int的切片。</p>\n<p>fmt.Println(sum())<br>\nfmt.Println(sum(3))<br>\nfmt.Println(sum(1, 2, 3, 4))\n原始参数已经是切片类型，我们该如何传递给sum❓。</p>\n<p>values := []int{1, 2, 3}\nfmt.Println(sum(values…))\n…int 型参数的行为看起来很像切片类型，但实可变参数函数和以切片作为参数的函数是不同的。</p>\n<p>func f(…int) {}\nfunc g([]int) {}\nfmt.Printf(&quot;%T\\n&quot;, f) // “func(…int)”\nfmt.Printf(&quot;%T\\n&quot;, g) // “func([]int)”\ngo\ndefer\n函数返回前执行的函数⛲️</p>\n<p>在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。\n可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。\n无论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束defer后的函数都会被执行。\n函数体内某个变量作为defer时匿名函数的参数，则在定义defer时即已经获得了拷贝，否则则是引用某个变量的地址。\npackage main\nimport (\n“fmt”\n)\nfunc main() {\n//函数返回前执行\ndefer fmt.Println(“defer1”)\ndefer fmt.Println(“defer2”)\nfmt.Println(“exit”)\n}\ngo\nalt\nimport (\n“fmt”\n)\nfunc fn() {\ndefer fmt.Println(“异常也会执行”)\nfmt.Println(“exit”)\npanic(“手动异常”)\n}\nfunc main() {\nfn()\n}\ngo\n拷贝还是引用</p>\n<p>package main\nimport “fmt”\nfunc main() {\ndefer fmt.Println(“hello defer”)\n// 拷贝还是引用\nfor i := 0; i &lt; 5; i++ {\n//普通匿名函数\nfunc() {\nfmt.Println(i)\n}()\n// defer 引用\ndefer func() {\nfmt.Println(“defer:”, i)\n}()\n// defer 拷贝\ndefer func(x int) {\nfmt.Println(“defer-:”, x)\n}(i)\n}\n}\ngo\n函数返回前⌛️</p>\n<p>package main\nimport “fmt”\nfunc main() {\nres := test(10)\nfmt.Println(res) //100\nres1 := test1(10)\nfmt.Println(res1) //101\n}\nfunc test(i int) int {\ndefer func() {\ni++\n}()\nreturn i * 10\n}\nfunc test1(i int) (r int) {\ndefer func() {\nr++\n}()\nr = i * 10\nreturn\n}\ngo\npanic异常\nGo的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。</p>\n<p>当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer）。\n随后程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。 -直接调用内置的panic函数也会引发panic异常。panic函数接受任何值interface{}作为参数。\nrecover捕获异常\n当异常发生的时候程序会停止运行。当一个web服务（教学管理系统）某一个模块出现问题（登陆）但其他模块应该可以正常提供服务（抢课）。</p>\n<p>在defer中调用了内置函数recover，recover会使程序从panic中恢复，并返回panic value。\n导致panic异常的函数不会继续运行，但能正常返回。\n在未发生panic时调用recover，recover会返回nil。\npackage main\nimport “fmt”\nfunc main() {\ndefer func() {\nif err := recover(); err != nil {\nfmt.Println(“defer:”, err)\n}\n}()\npanic(“提前终止程序”)\n}\ngo\n不影响其他功能</p>\n<p>package main\nimport “fmt”\nfunc fn1() {\n// defer func() {\n//     if err := recover(); err != nil {\n//         fmt.Println(“defer:”, err)\n//     }\n// }()\npanic(“panic”)\n}\nfunc fn2() {\ndefer func() {\nif err := recover(); err != nil {\nfmt.Println(“defer:”, err)\n}\n}()\nfmt.Println(“zxysilent”)\n}\nfunc main() {\nfor i := 0; i &lt; 3; i++ {\nfn1()\nfn2()\n}\n}</p>\n', 'images/wallhaven-629433.jpg', '', '8', '0', '');
INSERT INTO `card_list` VALUES ('1575371738', 'goweb-036-golang-Goroutines和Channels', '<p>goweb-036-golang-Goroutines和Channels\nGoroutines 协程\nChannels\n不带缓存的Channels\n带缓存的Channels\n并行同时做不同事。\nalt\n并发交替做不同事。\nalt\n假设你需要洗衣服和做饭</p>\n<p>串行：先洗完衣服再做饭，或者先做完饭再洗衣服。\n并发：一会洗衣一会做饭。\n并行：把洗衣盆拿到灶边，一只手做饭另一只手洗衣。\n为啥快 ⁉️\nGoroutines 协程\n传统的多线程模型中创建一个新的线程代价高昂8M。\nGo语言中，每一个并发的执行单元叫作一个goroutine（协程）。类比轻量级的线程2kb 。\n通过在普通函数前添加go直接启动新的协程执行。 更多细节请 <a href=\"https://golang.google.cn/ref/mem\">https://golang.google.cn/ref/mem</a> 官网走一波\n用示例说明\n传统模式</p>\n<p>package main\nimport (\n“fmt”\n“time”\n)\nfunc fn1() {\ntime.Sleep(1 * time.Second)\nfmt.Println(“暂停 1 s”)\n}\nfunc fn2() {\ntime.Sleep(2 * time.Second)\nfmt.Println(“暂停 2 s”)\n}\nfunc main() {\n//开始时间\nbegin := time.Now()\nfor i := 0; i &lt; 5; i++ {\nfn1()\nfn2()\n}\n//获取运行结束时间\nend := time.Now()\n//输出时间差\nfmt.Println(“总共用时:”, end.Sub(begin)) //总共用时: 15.0871782s\n}\ngo\n并发模式</p>\n<p>直接添加go开启新的协程 main函数的主协程并不会等待子协程结束需改造</p>\n<p>package main\nimport (\n“fmt”\n“sync”\n“time”\n)\nfunc fn1() {\ntime.Sleep(1 * time.Second)\nfmt.Println(“暂停 1 s”)\n// 执行完成就关闭一个等待\nwg.Done()\n}\nfunc fn2() {\ntime.Sleep(2 * time.Second)\nfmt.Println(“暂停 2 s”)\n// 执行完成就关闭一个等待\nwg.Done()\n}\n//WaitGroup 可以用来等待协程执行完成\nvar wg sync.WaitGroup\nfunc main() {\n//开始时间\nbegin := time.Now()\nfor i := 0; i &lt; 5; i++ {\ngo fn1()\n// 每次启动一个 协程\nwg.Add(1)\ngo fn2()\nwg.Add(1)\n}\n//等待所有子协程执行完成\nwg.Wait()\n//获取运行结束时间\nend := time.Now()\n//输出时间差\nfmt.Println(“总共用时:”, end.Sub(begin)) //总共用时: 2.015722s\n}\ngo\n时间就是金钱☢️</p>\n<p>Channels\nchannels则是goroutine之间的通信机制。一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。\n每个channel都有一个特殊的类型，也就是channel可发送数据的类型。\n一个可以发送int类型数据的channel一般写为chan int。\n抽象的东西往往不好理解，可以理解为一个队列的引用。</p>\n<p>内置的make函数，我们可以创建一个channel：</p>\n<p>ch := make(chan int)\n复制一个channel或用于函数参数传递时，只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。\n和其它的引用类型一样，channel的零值也是nil。</p>\n<p>一个channel有发送和接受两个主要操作(入队✍️出队)。\n发送和接收两个操作都使用&lt;-运算符。\n在发送语句中，&lt;-运算符分割channel和要发送的值。\n在接收语句中，&lt;-运算符写在channel对象之前。\nch &lt;- 10  // 发送\nx := &lt;-ch // 接收\n&lt;-ch\nChannel支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。</p>\n<p>ch := make(chan int)\nch &lt;- 10 // 发送\nclose(ch)\nx := &lt;-ch\n// val, ok:= &lt;- ch\nfmt.Println(x)\ngo\n以最简单方式调用make函数创建的是一个无缓存的channel，也可以指定第二个整型参数，对应channel的容量。如果大于零，那么该channel就是带缓存的channel。</p>\n<p>ch = make(chan int)<br>\nch = make(chan int, 0) //0 也没有缓冲\nch = make(chan int, 3)\n不带缓存的Channels\n无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作。\n如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。\n当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。\ncase1 阻塞</p>\n<p>ch := make(chan int)\nx := &lt;-ch\nfmt.Println(x)//fatal error: all goroutines are asleep - deadlock!\ncase2 阻塞</p>\n<p>ch := make(chan int)\nch &lt;- 100\nx := &lt;-ch\nfmt.Println(x)//fatal error: all goroutines are asleep - deadlock!\ngo\ncase3 不阻塞</p>\n<p>ch := make(chan int)\ngo func() {\nch &lt;- 100\n}()\nx := &lt;-ch\nfmt.Println(x)\ngo\n带缓存的Channels\n带缓存的Channel内部持有一个元素队列。\n队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。\nch = make(chan string, 3)\n在无阻塞的情况下连续向新创建的channel发送三个值 不阻塞。</p>\n<p>ch &lt;- “A”\nch &lt;- “B”\nch &lt;- “C”\n现在channel的内部缓存队列将是满的，如果现在有第四个发送操作将发生阻塞。</p>\n<p>alt\n接收一个值，</p>\n<p>fmt.Println(&lt;-ch) // “A”\nalt\n此时对channel执行的发送或接收操作都不会发生阻塞。</p>\n<p>内置的cap函数获取channel内部缓存的容量。</p>\n<p>fmt.Println(cap(ch)) // “3”\n内置的len函数，获取channel内部缓存队列中有效元素的个数。</p>\n<p>fmt.Println(len(ch)) // “2”\n类比饭馆吃饭\n要吃饭的人 &lt;-\n空位 chan\n&lt;-厨师\n更多的使用更多的理解✋(充分利用cpu性能)</p>\n', 'images/wallhaven-736090.jpg', '', '8', '0', '');
INSERT INTO `card_list` VALUES ('1575371834', 'json web token', '<p>JWT是json web token缩写。\n官网 它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。</p>\n<p>优点是在分布式系统中，很好地解决了单点登录问题，很容易解决了session共享的问题。\n缺点是无法作废已颁布的令牌/不易应对数据过期。\n数据格式</p>\n<p>Header\nPayload\nSignature\nxxxxx.yyyyy.zzzzz</p>\n<p>Signature=alt\n常用库\ngo get <a href=\"http://github.com/dgrijalva/jwt-go\">github.com/dgrijalva/jwt-go</a></p>\n<p>使用实例</p>\n<p>携带数据\n// JwtClaims jwt\ntype JwtClaims struct {\nId   int    <code>json:&quot;id&quot;</code>\nName string <code>json:&quot;name&quot;</code>\nNum  string <code>json:&quot;num&quot;</code>\nRole Role   <code>json:&quot;role&quot;</code>\njwt.StandardClaims\n}\nclean\n生成token\nclaims := model.JwtClaims{\nId:   <a href=\"http://mod.Id\">mod.Id</a>,\nName: <a href=\"http://mod.Name\">mod.Name</a>,\nNum:  mod.Num,\nRole: mod.Role,\nStandardClaims: jwt.StandardClaims{\nExpiresAt: time.Now().Add(time.Hour * 2).Unix(),\n},\n}\n// 保存唯一登陆信息\nutil.Save(<a href=\"http://claims.Id\">claims.Id</a>, claims.Rand)\n// Create token with claims\ntoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n// Generate encoded token and send it as response.\njwtStr, err := token.SignedString([]byte(“xxxx”))\nif err != nil {\nreturn ctx.JSON(util.NewFail(<code>凭证生成失败,请重试</code>, err.Error()))\n}\npgsql\n验证token\n// midJwt 中间件-jwt验证\nfunc midJwt(next echo.HandlerFunc) echo.HandlerFunc {\nreturn func(ctx echo.Context) error {\n// query form 查找 token\ntokenString := ctx.FormValue(“token”)\nif tokenString == “” {\n// header 查找token\ntokenString = ctx.Request().Header.Get(echo.HeaderAuthorization)\nif tokenString == “” {\nctx.JSON(util.NewErrJwt(<code>未发现jwt认证信息</code>))\nreturn nil\n}\n// Bearer token\ntokenString = tokenString[7:] //len(&quot;Bearer &quot;)\n}\njwtAuth := &amp;model.JwtClaims{}\njwt, err := jwt.ParseWithClaims(tokenString, jwtAuth, func(token *jwt.Token) (interface{}, error) {\nreturn []byte(“xxxx”), nil\n})\nif err == nil &amp;&amp; jwt.Valid {\nctx.Set(“auth”, jwtAuth)\n} else {\nreturn ctx.JSON(util.NewErrJwt(<code>对不起，请重新登陆^_^!&quot;,&quot;jwt验证失败</code>))\n}\nctx.Response().Header().Set(echo.HeaderServer, “by zxysilent”)\nreturn next(ctx)\n}\n}</p>\n', 'images/wallhaven-647733.jpg', '', '8', '0', '');
INSERT INTO `card_list` VALUES ('1575374632', 'goweb-030-golang-程序结构', '<p>命名\nGo语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个 简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意 数量的字母、数字或下划线。大写字母和小写字母是不同的：abc和aBc是两个不 同的名字。\n关键字\nbreak      default       func     interface   select\ncase       defer         go       map         struct\nchan       else          goto     package     switch\nconst      fallthrough   if       range       type\ncontinue   for           import   return      var\ngo\n还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。</p>\n<p>内建常量: true false iota nil\n内建类型: int int8 int16 int32 int64\nuint uint8 uint16 uint32 uint64 uintptr\nfloat32 float64 complex128 complex64\nbool byte rune string error\n内建函数: make len cap new append copy close delete\ncomplex real imag\npanic recover\ngo\n这些内部预先定义的名字并不是关键字，可以在定义中重新使用它们。</p>\n<p>声明\n声明语句定义了程序的各种实体对象以及部分或全部的属性。</p>\n<p>Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。\n一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件中。\n每个源文件以包的声明语句开始，说明该源文件是属于哪个包。\n包声明语句之后是import语句导入依赖的其它包然后是包一级的类型、变量、常量、函数的声明语句。\n包一级的各种类型的声明语句的顺序无关紧要。\n//当前程序包名称\npackage main\n//导入外部包\nimport (\n“fmt”\n)\n//常量\nconst TEL = 18284151024\n//包级别变量\nvar name = “zxysilent”\n// 新类型\ntype Int int\n//结构体\ntype S struct{}\n// 方法\nfunc (s S) Test() {}\n//接口\ntype obj interface{}\n//函数\nfunc main() {\n// 多个变量的声明\nvar a, b, c int\n// 多个变量的赋值\na, b, c = 1, 2, 3\n// 多个变量的声明同时赋值\nvar d, e, f int = 4, 5, 6\n// 多个变量的省略类型的声明赋值(编译器推断类型)\nvar g, h, i = 7, 8, 9\nfmt.Println(a, b, c, d, e, f, g, h, i)\nfmt.Println(“hello,word”)\n}\ngo\n变量\nvar声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。</p>\n<p>变量声明的一般语法如下：</p>\n<p>var 变量名字 类型 = 表达式\n其中类型或= 表达式两个部分可以省略其中的一个。</p>\n<p>默认值\n数值类型变量对应的零值是0。\n布尔类型变量对应的零值是false 。\n字符串类型对应的零值是空字符串。\n接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。\n数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。\n零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。</p>\n<p>var s string\nfmt.Println(s) // “”\nxxx\n一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。\n如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：\nvar i, j, k int                 // int, int, int\nvar b, f, s = true, 2.3, “four” // bool, float64, string\n初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化,局部变量将在声明语句被执行到的时候完成初始化。</p>\n<p>一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：\nvar f, err = os.Open(“filename”) //打开文件\n简短变量声明\n在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。\n它以名字 := 表达式形式声明变量，变量的类型根据表达式来自动推导。</p>\n<p>package main\nimport “fmt”\nfunc main() {\nz := “zxysilent”\nfmt.Println(z)\n}\ngo\n简短变量声明被广泛用于大部分的局部变量的声明和初始化。 var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p>\n<p>i := 100                  // an int\nvar boiling float64 = 100 // a float64\nvar names []string\nvar err error\nvar p Point\ngo\n简短变量声明语句也可以用来声明和初始化一组变量</p>\n<p>i, j := 0, 1\n✍ :=是一个变量声明语句，而=是一个变量赋值操作。Ⓜ️做题面试才会考</p>\n<p>i, j = j, i // 交换 i 和 j 的值\n和普通var形式的变量声明语句一样，简短变量声明语句也可以用函数的返回值来声明和初始化变量，像下面的os.Open函数调用将返回两个值：</p>\n<p>f, err := os.Open(name)\nif err != nil {\nreturn err\n}\nf.Close()\ngo\n简短变量声明左边的变量可能并不是全部都是刚刚声明的。\n如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。</p>\n<p>in, err := os.Open(“inputFile”)\n// …\nout, err := os.Create(“outputFile”)\n简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量</p>\n<p>指针\n用var x int声明语句声明一个x变量那么&amp;x表达式将产生一个指向该整数变量的指针\n指针对应的数据类型是<em>int，指针被称之为“指向int类型的指针”。\n如果指针名字为p，那么就说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。\n同时</em>p表达式对应p指针指向的变量的值。\nx := 1\np := &amp;x<br>\nfmt.Println(*p)\n*p = 2<br>\nfmt.Println(x)<br>\ngo\n返回函数中局部变量的地址也是安全的。</p>\n<p>var p = f()\nfunc f() *int {\nv := 1\nreturn &amp;v\n}\ngo\n指针包含了一个变量的地址，将指针作为参数调用函数，可以在函数中通过该指针来更新变量的值。</p>\n<p>func add(p *int) int{\n*p++\nreturn *p\n}\nv := 1\nadd(&amp;v)\nfmt.Println(add(&amp;v))\ngo\n每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。</p>\n<p>new函数\n另一个创建变量的方法是调用内建的new函数。 表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。</p>\n<p>p := new(int)   // p, *int 类型, 指向匿名的 int 变量\nfmt.Println(*p) // “0”\n*p = 2          // 设置 int 匿名变量的值为 2\nfmt.Println(*p) // “2”\ngo\n用new创建变量和普通变量声明语句方式创建变量没有什么区别，new函数类似是一种语法糖，而不是一个新的基础概念。</p>\n<p>func newInt() *int {\nreturn new(int)\n}\nfunc newInt() *int {\nvar dummy int\nreturn &amp;dummy\n}\ngo\n上面的两个函数有着相同的行为。\n由于new只是一个预定义的函数，可以将new名字重新定义为别的类型。</p>\n<p>func f(old, new int) int {\nreturn new - old\n}\nnew被定义为int类型的变量名，在函数内部是无法使用内置的new函数。</p>\n<p>生命周期\n变量的生命周期指的是在程序运行期间变量有效存在的时间段。</p>\n<p>包一级声明的变量的生命周期和整个程序的运行周期是一致的。\n局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。\n函数的参数变量和返回值变量都是局部变量。\npackage main\nimport “fmt”\nvar v = “1.0”\nfunc main() {\nz := “zxysilent”\nfmt.Println(z)\nfor i := 0; i &lt; 2; i++ {\nfmt.Println(i)\n}\nfmt.Println(add(10, 20))\n}\nfunc add(a, b int) int {\nreturn a + b\n}\ngo\n编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，不是由用var还是new声明变量的方式决定的。</p>\n<p>var global *int\nfunc f() {\nvar x int\nx = 1\nglobal = &amp;x\n}\nfunc g() {\ny := new(int)\n*y = 1\n}\ngo\n赋值\n使用赋值语句可以更新一个变量的值</p>\n<p>被赋值的变量 = 新值的表达式\nx = 1                    // 命名变量的赋值\n*p = true                // 通过指针间接赋值\n<a href=\"http://person.name\">person.name</a> = “bob”      // 结构体字段赋值\ncount[x] = count[x] * 10 // 数组、slice或map的元素赋值\ncount[x] *= 100\ngo\n数值变量也可以支持++递增和–递减语句\n❗️只能在后面</p>\n<p>v := 1\nv++    // 等价方式 v = v + 1；v 变成 2\nv--    // 等价方式 v = v - 1；v 变成 1\n元组赋值 略\n元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。\n在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。\nx, y = y, x\na[i], a[j] = a[j], a[i]\n//调用一个有多个返回值的函数\nf, err = os.Open(“foo.txt”)\ngo\n情况列举</p>\n<p>v, ok = m[key]        // map\nv, ok = x.(T)         // 断言\nv, ok = &lt;-ch          // channel 接收\nv = m[key]            // map查找，失败时返回零值\nv = x.(T)             // type断言，失败时panic异常\nv = &lt;-ch              // 管道接收，失败时返回零值（阻塞不算是失败）\n_, ok = m[key]        // map返回2个值\n_, ok = mm[&quot;&quot;], false // map返回1个值\n_ = mm[&quot;&quot;]            // map返回1个值\ngo\n可以用下划线空白标识符_来丢弃不需要的值。</p>\n<p>_, err = io.Copy(dst, src) // 丢弃字节数\n_, ok = x.(T)              // 只检测类型，忽略具体值\n类型\n变量或表达式的类型定义了对应存储值的属性特征，它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念✏️。</p>\n<p>type 类型名字 底层类型\n类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。</p>\n<p>package main\nimport (\n“fmt”\n)\n// MyInt type 类型名字 底层类型\ntype MyInt int\nfunc (i MyInt) String() string {\nreturn fmt.Sprintf(“myint:%d”, i)\n}\nfunc main() {\nvar i MyInt //= 100\ni = 100\nfmt.Println(i)\n}\ngo\n许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印。</p>\n<p>包和文件\n一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径。\n目录结构\nalt\n⭐️ max</p>\n<p>package util\n//Max 大的一个\nfunc Max(a, b int) int {\nif a &gt; b {\nreturn a\n}\nreturn b\n}\ngo\n⭐️ min</p>\n<p>package util\n//Min 小的一个\nfunc Min(a, b int) int {\nif a &gt; b {\nreturn b\n}\nreturn a\n}\ngo\n⭐️ main</p>\n<p>package main\nimport (\n“fmt”\n“tmp/util”\n)\nfunc main() {\na, b := 10, 20\nfmt.Println(util.Min(a, b))\nfmt.Println(util.Max(a, b))\n}\ngo\n导入包\nGo语言程序中，每个包都有一个全局唯一的导入路径。\n一个导入路径代表一个目录中的一个或多个Go源文件。\n除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（⚡️ 并不要求包名是唯一的），包名在包的声明处指定。 一个包的名字和包的导入路径的最后一个字段相同。</p>\n<p>临时重命名</p>\n<p>package main\nimport (\n“fmt”\nu “tmp/util”\n)\nfunc main() {\na, b := 10, 20\nfmt.Println(u.Min(a, b))\n}\ngo\n省掉包名</p>\n<p>package main\nimport (\n“fmt”\n. “tmp/util”\n)\nfunc main() {\na, b := 10, 20\nfmt.Println(Min(a, b))\n}\ngo\n包的初始化\n包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：</p>\n<p>var a = b + c // a 第三个初始化, 为 3\nvar b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)\nvar c = 1     // c 第一个初始化, 为 1\nfunc f() int { return c + 1 }\ngo\n如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。 init函数会优先于main函数执行</p>\n<p>func init() { /* … */ }\n在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用</p>\n<p>✍min</p>\n<p>package util\nimport (\n“fmt”\n)\nfunc init() {\nfmt.Println(“init min”)\n}\n//Min 小的一个\nfunc Min(a, b int) int {\nif a &gt; b {\nreturn b\n}\nreturn a\n}\ngo\n结果\nalt\ninit</p>\n<p>alt\n作用域 略\n预声明标识符的作用域为全域块。\n在顶级（即在任何函数之外）声明的表示常量、类型、变量或函数（而非方法）的标识符其作用域为该包块。\n已导入包的包名作用域为包含该导入声明的文件块。\n表示方法接收器、函数形参或返回值变量的标识符，其作用域为该函数体。\n在函数中声明为常量或变量的标识符，其作用域始于该函数中具体常量实现或变量实现ShortVarDecl表示短变量声明）的结尾，止于最内部包含块的结尾。\n在函数中声明为类型的标识符，其作用域始于该函数中具体类型实现的标识符，止于最内部包含块的结尾。\nfunc main() {\nx := “hello!”\nfor i := 0; i &lt; len(x); i++ {\nx := x[i]\nif x != ‘!’ {\nx := x + ‘A’ - ‘a’\nfmt.Printf(&quot;%c&quot;, x) // “HELLO”\n}\n}\n}</p>\n', 'images/【动漫原声】刺客伍六七OPED插曲合集.jpg', '', '8', '0', '');
INSERT INTO `card_list` VALUES ('1575949864', '还原window自带app', '<h1>Get all the provisioned packages</h1>\n<p>$Packages = (get-item ‘HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Appx\\AppxAllUserStore\\Applications’) | Get-ChildItem</p>\n<!--more-->\n<h1>Filter the list if provided a filter</h1>\n<p>$PackageFilter = $args[0]\nif ([string]::IsNullOrEmpty($PackageFilter))\n{\necho “No filter specified, attempting to re-register all provisioned apps.”\n}\nelse\n{\n$Packages = $Packages | where {$_.Name -like $PackageFilter}\nif ($Packages -eq $null)\n{\necho “No provisioned apps match the specified filter.”\nexit\n}\nelse\n{\necho “Registering the provisioned apps that match $PackageFilter”\n}as\n}\nForEach($Package in $Packages)\n{\n# get package name &amp; path\n$PackageName = $Package | Get-ItemProperty | Select-Object -ExpandProperty PSChildName\n$PackagePath = [System.Environment]::ExpandEnvironmentVariables(($Package | Get-ItemProperty | Select-Object -ExpandProperty Path))\n# register the package<br>\necho “Attempting to register package: $PackageName”\nAdd-AppxPackage -register $PackagePath -DisableDevelopmentMode\n}</p>\n', 'images/782aa057aefa004a822dbd4687459a7a.jpg', '', '8', '0', '');
INSERT INTO `card_list` VALUES ('1575949922', 'goweb-05-golang-操作数据库', '<p>使用数据库的一般步骤\nsqlx官网</p>\n<p>引入xxx\n第三方包 import “<a href=\"http://github.com/jmoiron/sqlx\">github.com/jmoiron/sqlx</a>”\n驱动 import _ “<a href=\"http://github.com/go-sql-driver/mysql\">github.com/go-sql-driver/mysql</a>”\n建立链接\n//uid:pass@tcp(host:port)/dbname?charset=utf8&amp;parseTime=true\n//用户名:密码@tcp(主机:端口)/数据库名称?charset=utf8&amp;parseTime=true\ndb, err = sqlx.Open(<code>mysql</code>, <code>root:root@tcp(127.0.0.1:3306)/news?charset=utf8&amp;parseTime=true</code>)\ngo\n测试链接\nerr = db.Ping()\n查询数据</p>\n<p>单个查询\npackage main\nimport (\n“fmt”\n_ “<a href=\"http://github.com/go-sql-driver/mysql\">github.com/go-sql-driver/mysql</a>”\n“<a href=\"http://github.com/jmoiron/sqlx\">github.com/jmoiron/sqlx</a>”\n)\n//Class db class\ntype Class struct {\nID   int\nName string\nDesc string\n}\nfunc main() {\ndb, err := sqlx.Open(<code>mysql</code>, <code>root:root@tcp(127.0.0.1:3306)/news?charset=utf8&amp;parseTime=true</code>)\nmod := &amp;Class{}\n//查询一条数据\n//错误信息 = db.Get(要保存数据的变量的指针,<code>sql语句</code>,参数…)\nerr = db.Get(mod, <code>select * from class limit 1</code>)\nfmt.Println(mod, err)\n}\ngo\n查询集合\npackage main\nimport (\n“fmt”\n_ “<a href=\"http://github.com/go-sql-driver/mysql\">github.com/go-sql-driver/mysql</a>”\n“<a href=\"http://github.com/jmoiron/sqlx\">github.com/jmoiron/sqlx</a>”\n)\n//Class db class\ntype Class struct {\nID   int\nName string\nDesc string\n}\nfunc main() {\ndb, err := sqlx.Open(<code>mysql</code>, <code>root:root@tcp(127.0.0.1:3306)/news?charset=utf8&amp;parseTime=true</code>)\nmods := make([]Class, 0)\n//查询多条数据\n//错误信息 = db.Select(要保存数据的变量的指针,<code>sql语句</code>,参数…)\nerr = db.Select(&amp;mods, <code>select * from class</code>)\nfmt.Println(&amp;mods, err)\n}\ngo\n操作数据\n添加数据\n//操作结果, 错误信息 := db.Exec(<code>sql语句</code>,参数…)\n//result, err := db.Exec(“insert into class(<code>name</code>,<code>desc</code>) values(?,?)”, <code>名称</code>, <code>描述description</code>)\nresult, err := db.Exec(“insert into class(<code>name</code>,<code>desc</code>) values(?,?)”, <code>名称</code>, <code>描述description</code>)\nfmt.Println(err)\n// 如果是insert数据 则LastInsertId 返回插入的 id\nfmt.Println(result.LastInsertId())\n// 修改和删除 RowsAffected 返回到底影响了多少条数据\nfmt.Println(result.RowsAffected())\ngo</p>\n<p>修改数据\n//修改数据\nresult, err := db.Exec(“update class set <code>desc</code>= ?”, <code>描述 描述</code>)//警告\nfmt.Println(err)\n// 如果是insert数据 则LastInsertId 返回插入的 id\nfmt.Println(result.LastInsertId())\n// 修改和删除 RowsAffected 返回到底影响了多少条数据\nfmt.Println(result.RowsAffected())\ngo</p>\n<p>删除数据\n//删除数据\nresult, err := db.Exec(“delete from class where id = ?”, 4) //警告\nfmt.Println(err)\n// 如果是insert数据 则LastInsertId 返回插入的 id\nfmt.Println(result.LastInsertId())\n// 修改和删除 RowsAffected 返回到底影响了多少条数据\nfmt.Println(result.RowsAffected())</p>\n', 'images/1574332002862.png', '', '8', '0', '');
INSERT INTO `card_list` VALUES ('1575950040', 'goweb-038-常用包net+http', '<p>网络操作(计算机网络相关知识可以利用此包实践)</p>\n<p>net\nnet包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket。\n本包提供了对网络原语的访问，大部分使用者只需要Dial、Listen和Accept函数提供的基本接口；以及相关的Conn和Listener接口。\n过程</p>\n<p>服务端程序 Listen 监听某个端口，等待客户端程序的连接请求Accept。\n客户端程序 Dial 申请连接。\n服务端程序 处理连接请求并建立网络连接 Conn\n双方在Conn 进行读Read/写Write操作传递数据。\n代码示例\nserver</p>\n<p>package main\nimport (\n“net”\n)\nfunc main() {\n//监听端口\nlisten, _ := net.Listen(“tcp”, <code>:88</code>)\nfor {\n//等待连接连接并建立连接\nconn, _ := listen.Accept()\n//通过连接发送数据\nconn.Write([]byte(<code>hello 我是服务端</code>))\n}\n}\ngo\nclient</p>\n<p>package main\nimport (\n“fmt”\n“net”\n)\nfunc main() {\n//请求建立连接\nconn, _ := net.Dial(“tcp”, “:88”)\n//数据容器\nbuf := make([]byte, 1024)\n//读取数据到容器\nl, _ := conn.Read(buf)\n//打印输出\nfmt.Println(string(buf[:l]))\n}\ngo\n模拟http\n浏览器访问 <a href=\"http://127.0.0.1:86/%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C\">http://127.0.0.1:86/查看效果</a></p>\n<p>alt\npackage main\nimport (\n“fmt”\n“net”\n)\nfunc main() {\n//监听端口\nlisten, _ := net.Listen(“tcp”, <code>:86</code>)\n//等待连接连接并建立连接\nconn, _ := listen.Accept()\n//http半双工需要先读取里面的数据\nbuf := make([]byte, 1024)\nl, _ := conn.Read(buf)\nfmt.Println(string(buf[:l]))\n//通过连接发送数据\n//http 协议格式\nconn.Write([]byte(“HTTP/1.1 200 OK\\r\\nContent-Type: text/plain;charset=UTF-8\\r\\n\\r\\n数据开始：net模拟http”))\nconn.Close()\n}\ngo\n浏览器\nalt\n控制台\nalt\nhttp\n官方文档\nnet的上层封装</p>\n<p>http包提供了HTTP客户端和服务端的实现。\nGet, Head, Post, and PostForm make HTTP (or HTTPS) requests:</p>\n<p>//普通get请求\nresp, err := http.Get(“<a href=\"http://example.com/\">http://example.com/</a>”)\n//上传文件\nbodyBuf := &amp;bytes.Buffer{}\nbodyWriter := multipart.NewWriter(bodyBuf)\nfileWriter, _ := bodyWriter.CreateFormFile(“file”, “main.go”)\nfh, _ := os.Open(“main.go”)\ndefer fh.Close()\nio.Copy(fileWriter, fh)\nctype := bodyWriter.FormDataContentType()\nbodyWriter.Close()\nhttp.Post(“<a href=\"http://127.0.0.1/up\">http://127.0.0.1/up</a>”, ctype, bodyBuf)\n//提交数据\nresp, err := http.PostForm(“<a href=\"http://example.com/form\">http://example.com/form</a>”,\nurl.Values{“key”: {“Value”}, “id”: {“123”}})\ngo\nThe client must close the response body when finished with it:</p>\n<p>resp, err := http.Get(“<a href=\"http://example.com/\">http://example.com/</a>”)\nif err != nil {\n// handle error\n}\ndefer resp.Body.Close()\nbody, err := ioutil.ReadAll(resp.Body)\n// …\ngo\nFor control over HTTP client headers, redirect policy, and other settings, create a Client:</p>\n<p>client := &amp;http.Client{\n}\nresp, err := client.Get(“<a href=\"http://example.com\">http://example.com</a>”)\n// …\nreq, err := http.NewRequest(“GET”, “<a href=\"http://example.com\">http://example.com</a>”, nil)\n// …\nreq.Header.Add(“If-None-Match”, <code>W/&quot;wyzzy&quot;</code>)\nresp, err := <a href=\"http://client.Do\">client.Do</a>(req)\ngo\n爬取页面</p>\n<p>package main\nimport (\n“fmt”\n“io/ioutil”\n“net/http”\n“regexp”\n)\nfunc main() {\n//发送http请求\nresp, err := http.Get(“<a href=\"http://www.cwnu.edu.cn/\">http://www.cwnu.edu.cn/</a>”)\nif err != nil {\npanic(err)\n}\ndefer resp.Body.Close()\n//读取响应数据\nbody, err := ioutil.ReadAll(resp.Body)\n//解析 a标签里面的 href数据\nreg, _ := regexp.Compile(<code>&lt;a.+href=&quot;(http.+?)&quot;</code>)\nres := reg.FindAllStringSubmatch(string(body), -1)\nfor idx := range res {\nfmt.Println(res[idx][1])\n//后续数据处理\n}\n}\ngo\nweb\n版本1</p>\n<p>package main\nimport (\n“net/http”\n)\nfunc index(w http.ResponseWriter, r *http.Request) {\nw.Write([]byte(<code>hello</code>))\n}\nfunc main() {\nhttp.HandleFunc(<code>/first</code>, index)\nhttp.ListenAndServe(&quot;:8080&quot;, nil)\n}\ngo\nalt\n巴拉巴拉。。。✍</p>\n<p>版本2</p>\n<p>package main\nimport (\n“io/ioutil”\n“net/http”\n“os”\n)\nfunc index(w http.ResponseWriter, r *http.Request) {\n//读取html文件\nf, _ := os.Open(<code>./index.html</code>)\n//读取数据\nbuf, _ := ioutil.ReadAll(f)\n//写入到响应\nw.Write(buf)\n}\nfunc main() {\nhttp.HandleFunc(<code>/first</code>, index)\n//静态文件访问 css img js 等\nhttp.Handle(&quot;/res/&quot;, http.StripPrefix(&quot;/res/&quot;, http.FileServer(http.Dir(&quot;./res&quot;))))\nhttp.ListenAndServe(&quot;:8080&quot;, nil)\n}\ngo\nhtml文件</p>\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>hello</title>\n</head>\n<body>\n    <div>index.html</div>\n    <script src=\"/res/js.js\"></script>\n</body>\n</html>\nhtml\njs 文件\n<p>alert(“res js”)</p>\n', 'images/1575964369876.png', '', '8', '0', '');
INSERT INTO `card_list` VALUES ('1575950109', 'goweb-037-golang-常用包', '<p>以示例的方式演示常用包的用法，更详细深入的信息请参考 <a href=\"https://golang.google.cn/pkg/%E6%A0%87%E5%87%86%E5%BA%93\">https://golang.google.cn/pkg/标准库</a>\nalt\nos\nos包提供了操作系统函数的不依赖平台的接口。设计为Unix风格的，错误处理是go风格的；失败的调用会返回错误值而非错误码。\n通常错误值里包含更多信息。\nos包的接口规定为在所有操作系统中都是一致的。</p>\n<p>打开一个文件并从中读取一些数据。</p>\n<p>file, err := os.Open(“file.go”)\nif err != nil {\nlog.Fatal(err)\n}\ngo\n如果打开失败，错误字符串是自解释的。\nopen file.go: no such file or directory</p>\n<p>文件的信息可以读取进一个[]byte切片。Read和Write方法从切片参数获取其内的字节数。</p>\n<p>data := make([]byte, 100)\ncount, err := file.Read(data)\nif err != nil {\nlog.Fatal(err)\n}\nfmt.Printf(“read %d bytes: %q\\n”, count, data[:count])\ngo\n标准的文件信息\ntype FileInfo interface {\nName() string       // base name of the file\nSize() int64        // length in bytes for regular files; system-dependent for others\nMode() FileMode     // file mode bits\nModTime() time.Time // modification time\nIsDir() bool        // abbreviation for Mode().IsDir()\nSys() interface{}   // underlying data source (can return nil)\n}\ngo\n常用方法\nStat\nfunc Stat(name string) (fi FileInfo, err error)\nStat返回一个描述name指定的文件对象的FileInfo。\nf, _ := os.Stat(<code>main.go</code>)\nfmt.Println(<a href=\"http://f.Name\">f.Name</a>(), f.IsDir(), f.ModTime())\nMkdir\nfunc Mkdir(name string, perm FileMode) error\nMkdir使用指定的权限和名称创建一个目录。\nos.Mkdir(<code>dir</code>, 0777)\nalt\nMkdirAll\nfunc MkdirAll(path string, perm FileMode) error\nMkdirAll使用指定的权限和名称创建一个目录，包括任何必要的上级目录，并返回nil，否则返回错误。\n权限位perm会应用在每一个被本函数创建的目录上。\n如果path指定了一个已经存在的目录，MkdirAll不做任何操作并返回nil。</p>\n<p>os.MkdirAll(<code>a/b/c/d</code>, 0777)\nalt\nRename\nfunc Rename(oldpath, newpath string) error\nRename修改一个文件的名字，移动一个文件。可能会有一些个操作系统特定的限制。</p>\n<p>os.Rename(<code>dir</code>, <code>dir1</code>)\nalt\nRemove\nfunc Remove(name string) error\nRemove删除name指定的文件或目录。\nos.Remove(<code>dir1</code>)\nalt\nRemoveAll\nfunc RemoveAll(path string) error\nRemoveAll删除path指定的文件，或目录及它包含的任何下级对象。它会尝试删除所有东西，除非遇到错误并返回。\n如果path指定的对象不存在，RemoveAll会返回nil而不返回错误。\nos.RemoveAll(<code>a</code>)\nalt\nCreate\nfunc Create(name string) (file *File, err error)\nCreate采用模式0666✋创建一个名为name的文件，如果文件已存在会置为空文件。\n如果成功，返回的文件对象可用于I/O；对应的文件描述符具有O_RDWR模式。</p>\n<p>Open\nfunc Open(name string) (file *File, err error) Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。</p>\n<p>fout, _ := os.Create(<code>output.txt</code>)\nfin, _ := os.Open(<code>main.go</code>)\nio.Copy(fout, fin)//io包\nOpenFile\nfunc OpenFile(name string, flag int, perm FileMode) (file *File, err error)\nOpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。\n它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。\n如果操作成功，返回的文件对象可用于I/O。\nfout, _ := os.Create(<code>output.txt</code>)\nfin, _ := os.OpenFile(<code>main.go</code>, os.O_RDWR, 0666)\nio.Copy(fout, fin)\nReaddir func (f *File) Readdir(n int) (fi []FileInfo, err error)\nReaddir读取目录f的内容，返回一个有n个成员的[]FileInfo，采用目录顺序。 对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。\n如果n&gt;0，Readdir函数会返回一个最多n个成员的切片。\n如果n&lt;=0，Readdir函数返回目录中剩余所有文件对象的FileInfo构成的切片。\ndir, _ := os.Open(<code>util</code>)\ndirs, _ := dir.Readdir(-1)\nfor idx := range dirs {\nfmt.Println(dirs[idx].Name())\n}\ngo\nRead\nfunc (f *File) Read(b []byte) (n int, err error)\nRead方法从f中读取最多len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取0个字节且返回值err为io.EOF。\nWrite\nfunc (f *File) Write(b []byte) (n int, err error)\nWrite向文件中写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。\nClose\nfunc (f *File) Close() error\nClose关闭文件f，使文件不能用于读写。它返回可能出现的错误。\nfin, _ := os.Open(<code>main.go</code>)\nfout, _ := os.Create(<code>output.txt</code>)\n//准备容器\nbuf := make([]byte, 128)\nfor {\nn, err := fin.Read(buf)\nif n == 0 || err == io.EOF {\nbreak\n}\nfout.Write(buf[:n])\n}\nfin.Close()\nfout.Close()\ngo\nWriteString\nfunc (f *File) WriteString(s string) (ret int, err error)\nWriteString 类似Write，但接受一个字符串参数。\nfout, _ := os.Create(<code>output.txt</code>)\ndefer fout.Close()\nfout.WriteString(<code>WriteString</code>)\nio &amp;&amp; ioutil\neof var EOF = errors.New(“EOF”)\nEOF当无法得到更多输入时，Read方法返回EOF☂️。当函数一切正常的到达输入的结束时，就应返回EOF。</p>\n<p>Copy func Copy(dst Writer, src Reader) (written int64, err error)</p>\n<p>将src的数据拷贝到dst，直到在src上到达EOF或发生错误。返回拷贝的字节数和遇到的第一个错误。\n对成功的调用，返回值err为nil而非EOF，因为Copy定义为从src读取直到EOF，它不会将读取到EOF视为应报告的错误。\nfout, _ := os.Create(<code>output.txt</code>)\nfin, _ := os.OpenFile(<code>main.go</code>, os.O_RDWR, 0666)\nio.Copy(fout, fin)\nioutil\nReadAll\nfunc ReadAll(r io.Reader) ([]byte, error)\nReadAll从r读取数据直到EOF或遇到error，返回读取的数据和遇到的错误。\n成功的调用返回的err为nil而非EOF。因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。\npackage main\nimport (\n“fmt”\n“io/ioutil”\n“log”\n“strings”\n)\nfunc main() {\nr := strings.NewReader(“Go is a general-purpose language designed with systems programming in mind.”)\nb, err := ioutil.ReadAll®\nif err != nil {\nlog.Fatal(err)\n}\nfmt.Printf(&quot;%s&quot;, b)\n}\ngo\nReadFile\nfunc ReadFile(filename string) ([]byte, error)\nReadFile 从filename指定的文件中读取数据并返回文件的内容。成功的调用返回的err为nil而非EOF。因为本函数定义为读取整个文件，它不会将读取返回的EOF视为应报告的错误。\npackage main\nimport (\n“fmt”\n“io/ioutil”\n“log”\n)\nfunc main() {\ncontent, err := ioutil.ReadFile(“testdata/hello”)\nif err != nil {\nlog.Fatal(err)\n}\nfmt.Printf(“File contents: %s”, content)\n}\ngo\nWriteFile\nfunc WriteFile(filename string, data []byte, perm os.FileMode) error\n函数向filename指定的文件中写入数据。如果文件不存在将按给出的权限创建文件，否则在写入数据之前清空文件。\npackage main\nimport “io/ioutil”\nfunc main() {\nioutil.WriteFile(“1.txt”, []byte(<code>string</code>), 0777)\n}\ngo\nReadDir func ReadDir(dirname string) ([]os.FileInfo, error)\n返回dirname指定的目录的目录信息的有序列表。\npackage main\nimport (\n“fmt”\n“io/ioutil”\n“log”\n)\nfunc main() {\nfiles, err := ioutil.ReadDir(&quot;.&quot;)\nif err != nil {\nlog.Fatal(err)\n}\nfor _, file := range files {\nfmt.Println(<a href=\"http://file.Name\">file.Name</a>())\n}\n}\ngo\nstrings\nCompare\nfunc Compare(a, b string) int\nCompare returns an integer comparing two strings lexicographically. The result will be 0 if a==b, -1 if a &lt; b, and +1 if a &gt; b.\npackage main\nimport (\n“fmt”\n“strings”\n)\nfunc main() {\nfmt.Println(strings.Compare(“a”, “b”))\nfmt.Println(strings.Compare(“a”, “a”))\nfmt.Println(strings.Compare(“b”, “a”))\n}\ngo\nContains\nfunc Contains(s, substr string) bool\nContains reports whether substr is within s.\npackage main\nimport (\n“fmt”\n“strings”\n)\nfunc main() {\nfmt.Println(strings.Contains(“seafood”, “foo”))\nfmt.Println(strings.Contains(“seafood”, “bar”))\nfmt.Println(strings.Contains(“seafood”, “”))\nfmt.Println(strings.Contains(&quot;&quot;, “”))\n}\ngo\nCount\nfunc Count(s, substr string) int\nCount counts the number of non-overlapping instances of substr in s. If substr is an empty string, Count returns 1 + the number of Unicode code points in s.\npackage main\nimport (\n“fmt”\n“strings”\n)\nfunc main() {\nfmt.Println(strings.Count(“cheese”, “e”))\nfmt.Println(strings.Count(“five”, “”)) // before &amp; after each rune\n}\ngo\nHasPrefix\nfunc HasPrefix(s, prefix string) bool\nHasPrefix tests whether the string s begins with prefix\npackage main\nimport (\n“fmt”\n“strings”\n)\nfunc main() {\nfmt.Println(strings.HasPrefix(“Gopher”, “Go”))\nfmt.Println(strings.HasPrefix(“Gopher”, “C”))\nfmt.Println(strings.HasPrefix(“Gopher”, “”))\n}\ngo\nHasSuffix func HasSuffix(s, suffix string) bool\nHasSuffix tests whether the string s ends with suffix.\npackage main\nimport (\n“fmt”\n“strings”\n)\nfunc main() {\nfmt.Println(strings.HasSuffix(“Amigo”, “go”))\nfmt.Println(strings.HasSuffix(“Amigo”, “O”))\nfmt.Println(strings.HasSuffix(“Amigo”, “Ami”))\nfmt.Println(strings.HasSuffix(“Amigo”, “”))\n}\ngo\nIndex\nfunc Index(s, substr string) int\nIndex returns the index of the first instance of substr in s, or -1 if substr is not present in s.\npackage main\nimport (\n“fmt”\n“strings”\n)\nfunc main() {\nfmt.Println(strings.Index(“chicken”, “ken”))\nfmt.Println(strings.Index(“chicken”, “dmr”))\n}\ngo\nJoin\nfunc Join(a []string, sep string) string\nJoin concatenates the elements of a to create a single string. The separator string sep is placed between elements in the resulting string.\npackage main\nimport (\n“fmt”\n“strings”\n)\nfunc main() {\ns := []string{“foo”, “bar”, “baz”}\nfmt.Println(strings.Join(s, “, “))\n}\ngo\nReplace func Replace(s, old, new string, n int) string\nReplace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n &lt; 0, there is no limit on the number of replacements.\npackage main\nimport (\n“fmt”\n“strings”\n)\nfunc main() {\nfmt.Println(strings.Replace(“oink oink oink”, “k”, “ky”, 2))\nfmt.Println(strings.Replace(“oink oink oink”, “oink”, “moo”, -1))\n}\ngo\nSplit func Split(s, sep string) []string Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators.\npackage main\nimport (\n“fmt”\n“strings”\n)\nfunc main() {\nfmt.Printf(”%q\\n”, strings.Split(“a,b,c”, “,”))\nfmt.Printf(&quot;%q\\n&quot;, strings.Split(“a man a plan a canal panama”, “a “))\nfmt.Printf(”%q\\n”, strings.Split(&quot; xyz “, “”))\nfmt.Printf(”%q\\n&quot;, strings.Split(&quot;&quot;, “Bernardo O’Higgins”))\n}\ngo\nToLower\nfunc ToLower(s string) string\nToLower returns a copy of the string s with all Unicode letters mapped to their lower case.</p>\n<p>package main\nimport (\n“fmt”\n“strings”\n)\nfunc main() {\nfmt.Println(strings.ToLower(“Gopher”))\n}\ngo\nToUpper\nfunc ToUpper(s string) string\nToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.</p>\n<p>package main\nimport (\n“fmt”\n“strings”\n)\nfunc main() {\nfmt.Println(strings.ToUpper(“Gopher”))\n}\ngo\nBuilder\n⚡️ A Builder is used to efficiently build a string using Write methods. It minimizes memory copying. The zero value is ready to use. Do not copy a non-zero Builder.</p>\n<p>type Builder struct {\n// contains filtered or unexported fields\n}\npackage main\nimport (\n“fmt”\n“strings”\n)\nfunc main() {\nvar b strings.Builder\nfor i := 3; i &gt;= 1; i-- {\nfmt.Fprintf(&amp;b, “%d…”, i)\n}\nb.WriteString(“ignition”)\nfmt.Println(b.String())\n}\ngo\nbytes\nbytes 包使用方式同strings包\nbytes 包操作对象为[]byte\nstrings包操作对象为string\n直接操作不舒服 正则走一波</p>\n', 'images/viewpoint_bg.png', '', '8', '0', '');
INSERT INTO `card_list` VALUES ('1576378581', 'python 数据分析', '<p>在SegmentFault上遇到一个问题，发现自己也不懂，找了资料弄懂了，翻译一下，加深印象。</p>\n<p><a href=\"http://xn--usc-1p8fq6e186d92co70a.edu\">本文翻译自usc.edu</a> slicing-arrays</p>\n<p>基于维度的切片\nPython的切片可以被用于数组，它基于每一个维度。例如有一个3x3的数组：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>a = reshape(arange(9), (3,3))\nprint(a)\n[[0 1 2]\n[3 4 5]\n[6 7 8]]\n1\n2\n3\n4\n5\n1\n2\n3\n4\n5\n如果只使用[:] 表示一个从数组开始到结束的切片：</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>print(a[:,:]) # 基于每一个维度，逗号前面是一个维度，后面是一个\n[[0 1 2]\n[3 4 5]\n[6 7 8]]\n1\n2\n3\n4\n1\n2\n3\n4\n也就是说，没有任何参数的切片[:] 和列表(list)的切片是一样的，可以理解为“取所有的索引”。但是数组切片和列表切片有一个重大的区别(见下文)。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>既然是基于维度，那么我们可以这样取第二维的第二个元素：</p>\n', 'images/6cd.jpg', '', '8', '0', '');
INSERT INTO `card_list` VALUES ('1576378671', 'python基础公开课', '<p>Python3 字典\n字典是另一种可变容器模型，且可存储任意类型对象。</p>\n<p>字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ,格式如下所示：</p>\n<p>d = {key1 : value1, key2 : value2 }\n键必须是唯一的，但值则不必。</p>\n<p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</p>\n<p>一个简单的字典实例：</p>\n<p>dict = {‘Alice’: ‘2341’, ‘Beth’: ‘9102’, ‘Cecil’: ‘3258’}\n也可如此创建字典：</p>\n<p>dict1 = { ‘abc’: 456 }\ndict2 = { ‘abc’: 123, 98.6: 37 }</p>\n', 'images/fenm.jpg', '', '8', '0', '');
INSERT INTO `card_list` VALUES ('1576379104', 'go-遗传算法-简单实现', '<p>ga(genetic algorithm)遗传算法\n求x+10<em>sin(5</em>x)+7<em>cos(4</em>x) 在[0,9]的最大值\n代码\ncore</p>\n<p>package core\nimport (\n“math”\n“math/rand”\n“time”\n)\n// Ga 遗传算法\ntype Ga struct {\n// 染色体长度\nLength int\n// 种群数量\nCount int\n// 种群\nPopulation []int\n//retain 适应度\nretain float64\n// 幸运者\nrandom float64\n// 变异几率\nmutation float64\n}\nfunc init() {\nrand.Seed(time.Now().UnixNano()) //利用当前时间的UNIX时间戳初始化rand包\n}\n// NewGa 初始化\nfunc NewGa(length, count int, retain, random, mutation float64) Ga {\nga := Ga{\nLength:   length,\nCount:    count,\nretain:   retain,\nrandom:   random,\nmutation: mutation,\n}\nga.Population = make([]int, count)\nfor i := 0; i &lt; count; i++ {\ntmp := 0\n// 随机生成染色体\nfor j := 0; j &lt; length; j++ {\ntmp |= (1 &lt;&lt; uint(j)) * rand.Intn(2)\n}\nga.Population[i] = tmp\n}\nreturn ga\n}\n// Evolve 进化\nfunc (ga <em>Ga) Evolve() {\n// 选择\nga.Selection()\n// 繁衍\nga.Crossover()\n// 变异\nga.Mutation()\n}\n// Selection 选择\nfunc (ga <em>Ga) Selection() {\n// 计算适应度\nfit := ga.Fitness()\n// 排序适应度\nfor i := 0; i &lt; ga.Count-1; i++ {\nfor j := i + 1; j &lt; ga.Count; j++ {\nif fit[i] &lt;= fit[j] {\nfit[i], fit[j] = fit[j], fit[i]\n// 种群与适应度统一\nga.Population[i], ga.Population[j] = ga.Population[j], ga.Population[i]\n}\n}\n}\n// 选择适应度强的染色体\nflag := int(float64(len(fit)) * ga.retain)\nparents := ga.Population[:flag]\nfor _, v := range ga.Population[flag:] {\nif rand.Float64() &lt; ga.random {\nparents = append(parents, v)\n}\n}\nga.Population = parents\n}\n// Fitness 计算适应度\nfunc (ga Ga) Fitness() []float64 {\nt := 1 &lt;&lt; uint(ga.Length)\nf := make([]float64, 0, ga.Count)\nfor idx := 0; idx &lt; ga.Count; idx++ {\ngf := float64(ga.Population[idx]) * 9.0 / float64(t)\n// 计算函数值\nf = append(f, gf+10</em>math.Sin(5</em>gf)+7<em>math.Cos(4</em>gf))\n}\nreturn f\n}\n// Crossover 繁衍\nfunc (ga *Ga) Crossover() {\npLen := len(ga.Population)\n// 需要的子代数量\ntargetCount := ga.Count - pLen\n// 子代种群\nchildren := make([]int, 0, targetCount)\nfor targetCount &gt; 0 {\nmale := rand.Intn(pLen)\nfemale := rand.Intn(pLen)\nif male != female {\ntargetCount–\n// 随机交叉点\ncrossPos := rand.Intn(ga.Length)\n// 生成掩码\nmask := 0\nfor i := 0; i &lt; crossPos; i++ {\nmask |= (1 &lt;&lt; uint(i))\n}\nmale = ga.Population[male]\nfemale = ga.Population[female]\n// 孩子获得父亲在交叉点之前的基因，和目前交叉点之后的基因\nchild := ((male &amp; mask) | (female &amp;^ mask)) &amp; (1&lt;&lt;uint(ga.Length) - 1)\nchildren = append(children, child)\n}\n}\n// 经过繁殖后的新种群\nga.Population = append(ga.Population, children…)\n}\n// Mutation 变异\nfunc (ga Ga) Mutation() {\nfor idx := 0; idx &lt; ga.Count; idx++ {\nif rand.Float64() &lt; ga.mutation {\nr := rand.Intn(ga.Length)\nga.Population[idx] ^= 1 &lt;&lt; (uint®)\n}\n}\n}\n// Resutl 结果\nfunc (ga *Ga) Resutl() float64 {\n// 计算适应度\nfit := ga.Fitness()\n// 排序适应度\nfor i := 0; i &lt; ga.Count-1; i++ {\nfor j := i + 1; j &lt; ga.Count; j++ {\nif fit[i] &lt;= fit[j] {\nfit[i], fit[j] = fit[j], fit[i]\n// 种群与适应度统一\nga.Population[i], ga.Population[j] = ga.Population[j], ga.Population[i]\n}\n}\n}\nt := 1 &lt;&lt; uint(ga.Length)\nreturn float64(ga.Population[0]) * 9.0 / float64(t)\n}\ngo\nmain</p>\n<p>package main\nimport (\n“fmt”\n“ga/core”\n)\nfunc main() {\nga := core.NewGa(17, 600, 0.2, 0.5, 0.01)\nfor i := 0; i &lt; 400; i++ {\nga.Evolve()\n}\nfmt.Println(ga.Resutl())\n}</p>\n', 'images/1_codingps_1566021498.jpg', '', '8', '0', 'GO');
INSERT INTO `card_list` VALUES ('1576379106', 'go-遗传算法-简单实现', '<p>ga(genetic algorithm)遗传算法\n求x+10<em>sin(5</em>x)+7<em>cos(4</em>x) 在[0,9]的最大值\n代码\ncore</p>\n<p>package core\nimport (\n“math”\n“math/rand”\n“time”\n)\n// Ga 遗传算法\ntype Ga struct {\n// 染色体长度\nLength int\n// 种群数量\nCount int\n// 种群\nPopulation []int\n//retain 适应度\nretain float64\n// 幸运者\nrandom float64\n// 变异几率\nmutation float64\n}\nfunc init() {\nrand.Seed(time.Now().UnixNano()) //利用当前时间的UNIX时间戳初始化rand包\n}\n// NewGa 初始化\nfunc NewGa(length, count int, retain, random, mutation float64) Ga {\nga := Ga{\nLength:   length,\nCount:    count,\nretain:   retain,\nrandom:   random,\nmutation: mutation,\n}\nga.Population = make([]int, count)\nfor i := 0; i &lt; count; i++ {\ntmp := 0\n// 随机生成染色体\nfor j := 0; j &lt; length; j++ {\ntmp |= (1 &lt;&lt; uint(j)) * rand.Intn(2)\n}\nga.Population[i] = tmp\n}\nreturn ga\n}\n// Evolve 进化\nfunc (ga <em>Ga) Evolve() {\n// 选择\nga.Selection()\n// 繁衍\nga.Crossover()\n// 变异\nga.Mutation()\n}\n// Selection 选择\nfunc (ga <em>Ga) Selection() {\n// 计算适应度\nfit := ga.Fitness()\n// 排序适应度\nfor i := 0; i &lt; ga.Count-1; i++ {\nfor j := i + 1; j &lt; ga.Count; j++ {\nif fit[i] &lt;= fit[j] {\nfit[i], fit[j] = fit[j], fit[i]\n// 种群与适应度统一\nga.Population[i], ga.Population[j] = ga.Population[j], ga.Population[i]\n}\n}\n}\n// 选择适应度强的染色体\nflag := int(float64(len(fit)) * ga.retain)\nparents := ga.Population[:flag]\nfor _, v := range ga.Population[flag:] {\nif rand.Float64() &lt; ga.random {\nparents = append(parents, v)\n}\n}\nga.Population = parents\n}\n// Fitness 计算适应度\nfunc (ga Ga) Fitness() []float64 {\nt := 1 &lt;&lt; uint(ga.Length)\nf := make([]float64, 0, ga.Count)\nfor idx := 0; idx &lt; ga.Count; idx++ {\ngf := float64(ga.Population[idx]) * 9.0 / float64(t)\n// 计算函数值\nf = append(f, gf+10</em>math.Sin(5</em>gf)+7<em>math.Cos(4</em>gf))\n}\nreturn f\n}\n// Crossover 繁衍\nfunc (ga *Ga) Crossover() {\npLen := len(ga.Population)\n// 需要的子代数量\ntargetCount := ga.Count - pLen\n// 子代种群\nchildren := make([]int, 0, targetCount)\nfor targetCount &gt; 0 {\nmale := rand.Intn(pLen)\nfemale := rand.Intn(pLen)\nif male != female {\ntargetCount–\n// 随机交叉点\ncrossPos := rand.Intn(ga.Length)\n// 生成掩码\nmask := 0\nfor i := 0; i &lt; crossPos; i++ {\nmask |= (1 &lt;&lt; uint(i))\n}\nmale = ga.Population[male]\nfemale = ga.Population[female]\n// 孩子获得父亲在交叉点之前的基因，和目前交叉点之后的基因\nchild := ((male &amp; mask) | (female &amp;^ mask)) &amp; (1&lt;&lt;uint(ga.Length) - 1)\nchildren = append(children, child)\n}\n}\n// 经过繁殖后的新种群\nga.Population = append(ga.Population, children…)\n}\n// Mutation 变异\nfunc (ga Ga) Mutation() {\nfor idx := 0; idx &lt; ga.Count; idx++ {\nif rand.Float64() &lt; ga.mutation {\nr := rand.Intn(ga.Length)\nga.Population[idx] ^= 1 &lt;&lt; (uint®)\n}\n}\n}\n// Resutl 结果\nfunc (ga *Ga) Resutl() float64 {\n// 计算适应度\nfit := ga.Fitness()\n// 排序适应度\nfor i := 0; i &lt; ga.Count-1; i++ {\nfor j := i + 1; j &lt; ga.Count; j++ {\nif fit[i] &lt;= fit[j] {\nfit[i], fit[j] = fit[j], fit[i]\n// 种群与适应度统一\nga.Population[i], ga.Population[j] = ga.Population[j], ga.Population[i]\n}\n}\n}\nt := 1 &lt;&lt; uint(ga.Length)\nreturn float64(ga.Population[0]) * 9.0 / float64(t)\n}\ngo\nmain</p>\n<p>package main\nimport (\n“fmt”\n“ga/core”\n)\nfunc main() {\nga := core.NewGa(17, 600, 0.2, 0.5, 0.01)\nfor i := 0; i &lt; 400; i++ {\nga.Evolve()\n}\nfmt.Println(ga.Resutl())\n}</p>\n', 'images/464ba5e3ae5c6b5f8ebdb607d979b423.png', '', '8', '0', 'GO');
INSERT INTO `card_list` VALUES ('1576379177', 'Server Side Include', '<p>Server Side Include\ndescription\nNginx配置SSI\n使用SSI\nbase\ninclude\necho\nflastmod\nfsize\nexec\nconfig\ndescription\n服务器端嵌入或者叫服务器端包含，是Server Side Include的简写。SSI技术通过在文档中加入SSI指令，让服务器端在输出文档之前解析SSI指令，并把解析完的结果和文档一同输出给客户端。</p>\n<p>Nginx配置SSI\nserver {<br>\nlisten  10.3.9.27:80;<br>\nserver_name  <a href=\"http://www.zxysilent.com\">www.zxysilent.com</a>;<br>\nlocation / {<br>\nssi on;<br>\nssi_silent_errors on;<br>\nssi_types text/shtml;<br>\nindex index.shtml;<br>\nroot /usr/local/web/wwwroot;<br>\nexpires 30d;<br>\naccess_log      /data/logs/ www.zxysilent.com-access_log main;<br>\n}<br>\n}<br>\nnginx\n使用SSI\nbase\n格式：&lt;!-- #指令名称 参数=“参数值”&gt;</p>\n<p>eg： <!--#include file=\"info.htm\"--></p>\n<p>说明：<!-- -->是HTML语法中表示注释，当WEB服务器不支持SSI时，会忽略这些信息。</p>\n<p>#include 为SSI指令之一。 file 为include的参数， info.htm为参数值，在本指令中指将要包含的文档名。</p>\n<p>注意 前面与#号间无空格，只有SSI指令与参数间存在空格。 SSI指令是大小写敏感的，因此参数必须是小写才会起作用。</p>\n<p>include\n把其它文档插入到当前被解析的文档中</p>\n<!--#include file=\"file_name_extension\"--> \n<p>file 指定包含文件相对于本文档的位置</p>\n<!--#include virtual=\"/path/file_name_extension\"-->\n<p>virtual 指定相对于服务器文档根目录的位置</p>\n<p>file 文件名是一个相对路径，该路径相对于使用 #include 指令的文档所在的目录。被包含文件可以在同一级目录或其子目录中，但不能在上一级目录中。如表示当前目录下的的naver.html文档，则为file=“naver.html。\nvirtual 文件名是 Web 站点上的虚拟目录的完整路径。如表示相对于服务器文档根目录下inc目录下的naver.html文件；则为 virtual=”/inc/naver.html&quot; 注意 文件名称必须带有扩展名。\necho\n将环境变量插入到页面中</p>\n<!--#echo var=\"变量名称\"-->\n<p>eg</p>\n<!--#echo var=\"DOCUMENT_NAME\"--> 本文档名称\n<!--#echo var=\"DATE_LOCAL\"--> 现在时间\n<!--#echo var=\"REMOTE_ADDR\"--> 你的IP地址\n<p>xml\nflastmod\n显示指定文件的最后修改日期</p>\n<!--#flastmod file=\"file_name_extension\"--> \n<!--#flastmod virtual=\"/path/file_name_extension\"-->\n<p>fsize\n显示文件的大小</p>\n<!--#fsize file=\"文件名称\"-->\n<p>exec\n将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是cgi</p>\n<!--#exec cmd=\"file_name_extension\"-->\n<p>cmd 常规应用程序</p>\n<!--#exec cgi=\"file_name_extension\"-->\n<p>CGI脚本程序 eg</p>\n<!--#exec cmd=\"dir /b\"--> 将会显示当前目录下文件列表\n<!--#exec cgi=\"/cgi-bin/demo.cgi\"--> 将会执行CGI程序demo.cgi。\n<p>config\n指定返回给客户端浏览器的错误信息、日期和文件大小的格式</p>\n<!--#config errmsg=\"自定义错误信息\"-->\n<p>errmsg 自定义SSI执行错误信息，可以为任何你喜欢的方式。</p>\n<!--#config sizefmt=\"显示单位\"-->\n<p>sizefmt 文件大小显示方式，默认为字节方式(“bytes”)可以改为千字节方式(“abbrev”)</p>\n<!--#config timefmt=\"显示格式\"-->\n<p>timefmt 时间显示方式，最灵活的配置属性。</p>\n<p>eg</p>\n<p>显示一个不存在文件的大小</p>\n<!--#config errmsg=\"服务器执行错误，请联系管理员\"-->\n<!--#fsize file=\"noexist.htm\"-->\n<p>以千字节方式显示文件大小</p>\n<!--#config sizefmt=\"abbrev\"-->  \n<!--#fsizefile=\"news.htm\"-->\n<p>以特定的时间格式显示时间</p>\n<!--#config timefmt=\"%Y年/%m月%d日 星期%W 北京时间%H:%M:%s，%Y年已过去了%j天 今天是%Y年的第%U个星期\"-->\n<!--#echo var=\"DATE_LOCAL\"--> 显示今天是星期几，几月，时区\n<p>时间格式</p>\n<p>%a 一周中某天的缩写（例如，Mon）。\n%A 一周中某天的全称（例如，Monday）。\n%b 月份的缩写（例如，Feb）。\n%B 月份的全称（例如，February）。\n%c 当地的日期和时间的表示（例如，05/06/91 12:51:32）。\n%d 以十进制数字表示的一个月中的某天 (01-31)。\n%H 24 小时格式 (00-23)。\n%I 12 小时格式 (01-12)。\n%j 以十进制数字表示一年中的某天 (001-366)。\n%m 以十进制数字表示的月份 (01-12)。\n%M 以十进制数字表示的分 (00-59)。\n%p 当地的上午或下午指示符（例如，PM）。\n%S 以十进制数字表示的秒 (00-59)。\n%U 以十进制数字表示一年中的某一周，星期日作为一周的开始 (00-51)。\n%w 以十进制数字表示一周中的某一天，星期天是第一天 (0-6)。\n%W 以十进制数字表示一年中的某一天，星期一作为一周的开始 (00-51)。\n%x 当地的日期表示（例如，05/06/91）。\n%X 当地的时间表示（例如，12:51:32）。\n%y 以十进制数字表示的不带有世纪的年（例如，69）。\n%Y 以十进制数字表示的带有世纪的年（例如，1969）。\n%z, %Z 时区全称或缩写；如果不知道时区，则没有字符。</p>\n', 'images/1_design407_1574320891.jpg', '', '8', '0', '');
INSERT INTO `card_list` VALUES ('1576379242', 'javascriptDOM操作', '<p>1.创建元素\n创建元素：document.createElement()</p>\n<p>使用document.createElement()可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在HTML文档中不区分大小写，在XHTML中区分大小写。</p>\n<p>var div = document.createElement(“div”);</p>\n<p>使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocument属性，可以操作元素的特性。</p>\n<p><a href=\"http://div.id\">div.id</a> = “myDiv”;\ndiv.className = “div1”;\n此时，新元素尚未被添加到文档树中，因此设置各种特性均不会影响浏览器的显示。要添加到文档树，可用appendChild()、insertBefore()、replaceChild()。</p>\n<p>document.body.appendChild(div);</p>\n<p>当把元素添加到文档树中后，这时这个元素做的任何修改都会实时地反应到浏览器中。</p>\n<p>在IE中可以为createElement()方法传入完整的元素标签和属性。(只在IE中兼容)</p>\n<p>var div = document.createElement(&quot;&lt;div id=“mydiv” class=“div1”&gt;</div>&quot;);</p>\n<p>不能再标签里加其他元素节点或者文本节点，如下的方式和上面的得出的节点一样</p>\n<p>var div = document.createElement(&quot;&lt;div id=“mydiv” class=“div1”&gt;12212</div>&quot;);</p>\n<p>创建文本节点 ：document.createTextNode</p>\n<p>使用document.createTextNode()来创建文本节点，这个方法接受一个参数：要插入节点的文本。与设置已有文本节点的值一样，作为参数的文本将按照HTML或XML的格式进行编码。</p>\n<p>document.createTextNode(“121212”); 可以添加多个文本节点。假如两个文本节点时相邻的同胞节点，那么两个文本节点会连起来，中间不会有空格。</p>\n<p>2.节点关系\n（IE9以前不将换行和空格看做文本节点，其他浏览器会）</p>\n<p>文本关系如下：</p>\n<div id=\"div1\">\n    <div id=\"div2\">2</div>\n    <div id=\"div3\">3</div>\n    <div id=\"div4\">4</div>\n</div>\napplescript\n父节点：parentNode\n<p>parentNode是指定节点的父节点.一个元素节点的父节点可能是一个元素(Element )节点,也可能是一个文档(Document )节点,或者是个文档碎片(DocumentFragment)节点. 每一个节点都有一个parentNode属性。</p>\n<p>对于下面的节点类型: Attr, Document, DocumentFragment, Entity, Notation,其parentNode属性返回null。如果当前节点刚刚被创建,还没有被插入到DOM树中,则该节点的parentNode属性也返回null。</p>\n<script type=\"text/javascript\">\n    var child2 = document.getElementById(\"div2\");\n    var parent = child2.parentNode;\n</script>\n<p>xml\n子节点：childNodes</p>\n<p>childNodes 返回包含指定节点的子节点的集合，该集合为实时更新的集合（live collection）。 实时更新就是对节点元素的任意修改都会立即反映到结果里。</p>\n<script type=\"text/javascript\">\n    var child2 = document.getElementById(\"div2\");\n    var parent = child2.parentNode;\n    var allChilds = parent.childNodes;\n    console.log(allChilds.length) // IE下是3，其他浏览器是7\n    var nodeAdd = document.createElement(\"div\");\n    var textAdd = document.createTextNode(\"这是添加的文本节点\");\n    nodeAdd.appendChild(textAdd);\n    parent.appendChild(nodeAdd);\n    console.log(allChilds.length);// IE下是4，其他浏览器是8\n</script>\n<p>xml\n兄弟节点：nextSibling，previousSibling</p>\n<p>nextSibling返回某节点的下一个兄弟节点，previousSibling返回某节点的上一个兄弟节点，没有的话返回null。 注意：可能因为元素换行的原因返回的是text节点。</p>\n<script type=\"text/javascript\">\n    var child3 = document.getElementById(\"div3\");\n    var next = child3.nextSibling;\n    var previous = child3.previousSibling;\n    console.log(next); // IE下返回div4，其他返回text\n    console.log(previous)  // IE下返回div2，其他返回text\n</script>\n<p>xml\n第一个或最后一个子节点：firstChild、lastChild</p>\n<p>firstChild返回node的子节点中的第一个节点的引用，没有返回null lastChild返回node的子节点中的最后一个节点的引用，没有返回null</p>\n<script type=\"text/javascript\">\n    var child3 = document.getElementById(\"div3\");\n    var parent = child3.parentNode;\n    var first = parent.firstChild; // IE是div2，其他是text\n    var last = parent.lastChild; // IE是div4，其他是text\n</script>\n<p>xml\n3.节点元素关系\n只算元素，不算文本节点。</p>\n<p>以下三个方法用法和节点关系完全一样，只是这三个方法只看元素节点，不管因为空格、换行造成的文本节点或者手动加上去的文本节点。</p>\n<p>children： 返回所有元素子节点（IE5+、ff3.5、opera3、chrome，但在IE8及以下会将注释节点看成一个元素节点）</p>\n<p>以下两个IE9+才支持</p>\n<p>nextElementSibling：返回元素的下一个兄弟元素节点 previousElementSibling: 返回元素的上一个兄弟元素节点</p>\n<p>4.节点操作\nappendChild()</p>\n<p>appendChild()用于向childNodes列表的末尾添加一个节点，并且返回这个新增的节点。 如果传入到appendChild()里的节点已经是文档的一部分了，那结果就是将节点从原来的位置转移到新位置，任何一个节点不能同时出现在文档中的多个位置。</p>\n<pre><code>var returnNode = someNode.appendChild(someNode.firstChild); // 返回第一个节点\nconsole.log(returnNode === someNode.firstChild); // false\nconsole.log(returnNode === someNode.lastChild); // true\n</code></pre>\n<p>insetBefore()</p>\n<p>insetBefore()可以将节点插入到某个特定的位置。这个方法接受两个参数：要插入的节点和作为参照的节点。 插入节点后，被插入的节点变成参照节点的前一个同胞节点，同时被方法返回。 如果参照节点是null，则与appendChild()执行相同的操作。</p>\n<pre><code>// 插入后成为最后一个子节点\nvar returnNode = someNode.insetBefore(newNode, null);\nconsole.log(returnNode === someNode.lastChild); // true\n// 插入后成为第一个子节点\nvar returnNode = someNode.insetBefore(newNode, someNode.firstChild);\nconsole.log(returnNode === newNode); // true\nconsole.log(returnNode === someNode.firstChild); // true\n// 插入到最后一个子节点的前面\nvar returnNode = someNode.insetBefore(newNode, someNode.lastChild);\nconsole.log(returnNode === someNode.childNodes[someNode.childnodes.length - 2]) // true\n</code></pre>\n<p>haxe\n替换节点： replaceChild()</p>\n<p>replaceChild()接受两个参数：要插入的节点和要被替换的节点。被替换的节点将由这个方法返回并从文档中被移除，同时由要插入的节点占据其位置。</p>\n<p>// 替换第一个子节点\nvar returnNode = someNode.replaceChild(newNode, someNode.firstChild);\n使用replaceChild()后，被替换的节点的所有关系指针都会被复制到插入的节点上面。</p>\n<p>删除节点：removeChild()</p>\n<p>该方法移除节点，接受一个参数，即要移除的节点，同时该方法返回被移除的节点。只能是一个节点，不能是一组节点。</p>\n<p>// 移除第一个子节点\nvar returnNode = someNode.removeChild(newNode, someNode.firstChild);\n克隆节点：cloneNode(true/false)</p>\n<p>返回调用该方法的节点的一个副本。参数表示是否采用深度克隆,如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身，文本或者换行、空格这些不会复制，因为他们都是一个textNode。</p>\n<p>注意 : 在DOM4规范中(实现于Gecko 13.0(Firefox 13.0 / Thunderbird 13.0 / SeaMonkey 2.10) , 查看 bug 698391),deep是一个可选参数. 如果省略的话, deep参数的默认值为true,也就是说,深度克隆是默认的.如果想使用浅克隆, 你需要将该参数指定为false。</p>\n<p>在旧版本的浏览器中, 你始终需要指定deep参数。</p>\n<p>克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如onclick=“alert(1)”),但不会拷贝那些使用addEventListener()方法或者node.onclick = fn这种用JavaScript动态绑定的事件。</p>\n<p>注意:为了防止一个文档中出现两个ID重复的元素,使用cloneNode()方法克隆的节点在需要时应该指定另外一个与原ID值不同的ID</p>\n<pre><code>var div1 = document.getElementById(&quot;div1&quot;);\nvar cloneHtml = div1.cloneNode(true);\ndocument.body.appendChild(cloneHtml);\n</code></pre>\n<p>5.元素选择\nHTML代码示例：</p>\n<pre><code>&lt;div id=&quot;div1&quot;&gt;\n    &lt;p id=&quot;div2&quot; class=&quot;one&quot; name=&quot;nameone&quot;&gt;2&lt;/p&gt;\n    &lt;div id=&quot;div3&quot;&gt;3&lt;/div&gt;\n    &lt;div id=&quot;div4&quot; name=&quot;div2&quot;&gt;4&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>applescript\nquerySelector、querySelectorAll(IE8及以上)</p>\n<p>Selectors API通过匹配一组选择器的方式来为从DOM中检索Element节点提供一些简单快捷的方法，这比过去必须要在javascript代码中用循环来查找某个你想要的特定元素更快一些。 该规范对于使用Document,DocumentFragment和Element接口的对象都增了两种新方法：</p>\n<p>querySelector</p>\n<p>返回节点子树内与之相匹配的第一个Element节点。如果没有匹配的节点，则返回null。</p>\n<p>querySelectorAll</p>\n<p>返回一个包含节点子树内所有与之相匹配的Element节点列表，如果没有相匹配的，则返回一个空节点列表。 注意：由 querySelector()、querySelectorAll()返回的节点列表不是动态实时的（非live Collection）。这和其他DOM查询方法返回动态实时节点列表不一样。</p>\n<p>选择器方法接受一个或多个用逗号分隔的选择器来确定需要被返回的元素。例如，要选择文档中所有CSS的类(class)是warning或者note的段落§元素,可以这样写：</p>\n<p>var special = document.querySelectorAll( “p.warning, p.note” ); 也可以通过ID来查询，例如：</p>\n<p>var el = document.querySelector( “#main, #basic, #exclamation” ); 执行上面的代码后，el就包含了文档中元素的ID是main，basic或exclamation的所有元素中的第一个元素。</p>\n<p>querySelector() and querySelectorAll() 里可以使用任何CSS选择器，他们都不是live Collection：</p>\n<p>var notLive = document.querySelectorAll(“p”);\nconsole.log(notLive);\ndocument.getElementById(“div1”).removeChild(document.getElementById(“div2”));\nconsole.log(notLive);\n// 上面两个输出都是输出 <code>p#div2.one</code>的引用，没有因为删除了<code>p</code>标签而使<code>notLive</code>的结果发生变化。\ncoffeescript\ngetElementById()</p>\n<p>返回一个匹配特定 ID的元素。id是大小写敏感的字符串，代表了所要查找的元素的唯一ID，如果没有则返回null。 如果新建一个元素，还没有插入到文档中，则不能通过该方法获取到。</p>\n<pre><code>var notLive = document.getElementById(&quot;div2&quot;);\nconsole.log(notLive.innerHTML);\ndocument.getElementById(&quot;div1&quot;).removeChild(document.getElementById(&quot;div2&quot;));\nconsole.log(notLive.innerHTML);\n// 上面输出都是2，说明getElementById()也是**非**live collection\n</code></pre>\n<p>javascript\ngetElementsByTagName()</p>\n<p>document.getElementsByTagName() 方法返回一个实时的包含具有给出标签名的元素们的HTMLCollection。指定的元素的子树会被搜索，包括元素自己。返回的 list 是实时的（live collection），意味着它会随着DOM树的变化自动更新。因此，如果对同一个元素，使用相同的参数，是不需要多次调用document.getElementsByTagName() 的。</p>\n<p>Element.getElementsByTagName()的搜索被限制为指定元素的后代而不是document</p>\n<p>var live = document.getElementsByTagName(“p”);\nconsole.log(live[0].innerHTML);\ndocument.getElementById(“div1”).removeChild(document.getElementById(“div2”));\nconsole.log(live[0].innerHTML);\n// 第一个输出2，第二个报错，因为无法引用到p标签\njavascript\ngetElementsByName()</p>\n<p>该方法返回一个实时的nodelist collection，包含文档中所有name属性匹配的标签。这是一个 live collection。 注意：在IE和opera下，如果某个元素1的name和另一个元素2的id重合，且元素2在元素1的前面，则getElementsByName()会取到元素2。</p>\n<pre><code>var live = document.getElementsByName(&quot;div2&quot;);\nconsole.log(live[0].innerHTML);\ndocument.getElementById(&quot;div1&quot;).removeChild(document.getElementById(&quot;div2&quot;));\nconsole.log(live[0].innerHTML);\n// chrome下：全部输出4\n// IE下： 第一个输出2，第二个报错。\n</code></pre>\n<p>javascript\ngetElementsByClassName()</p>\n<p>该方法返回一个即时更新的（live） HTMLCollection，包含了所有拥有指定 class 的子元素。当在 document 对象上调用此方法时，会检索整个文档，包括根元素。(IE9以下不支持)</p>\n<p>要匹配多个class，则className用空格分开。</p>\n<p>getElementsByClassName(“class1 class2”);\nvar live = document.getElementsByClassName(“one”);\nconsole.log(live[0].innerHTML);\ndocument.getElementById(“div1”).removeChild(document.getElementById(“div2”));\nconsole.log(live[0].innerHTML);\n// 第一个返回2，第二个报错\njavascript\n6.属性操作\nsetAttribute()</p>\n<p>添加一个新属性（attribute）到元素上，或改变元素上已经存在的属性的值。</p>\n<p>当在 HTML 文档中的 HTML 元素上调用 setAttribute() 方法时，该方法会将其属性名称（attribute name）参数小写化。</p>\n<p>如果指定的属性已经存在，则其值变为传递的值。如果不存在，则创建指定的属性。也可指定为null。如果设置为null，最好使用removeAttribute()。</p>\n<pre><code>var div2 = document.getElementById(&quot;div2&quot;);\ndiv2.setAttribute(&quot;class&quot;, &quot;new_class&quot;);\ndiv2.setAttribute(&quot;id&quot;, &quot;new_id&quot;);\n</code></pre>\n<p>mipsasm\n注意：在IE7下，修改了元素的class，如果已有class，则会出现两个class，通过setAttribute()添加的不生效；如果没有class，则添加上class，但这个添加上去的class的样式不会生效。</p>\n<p>removeAttribute()</p>\n<p>该方法用于移除元素的属性。</p>\n<pre><code>var div2 = document.getElementById(&quot;div2&quot;);\ndiv2.removeAttribute(&quot;class&quot;);\n</code></pre>\n<p>注意：IE7下无法移除 class 属性</p>\n<p>getAttribute()</p>\n<p>该方法返回元素上指定属性（attribute）的值。如果指定的属性不存在，则返回 null 或 “” （空字符串）（IE5+都返回null）。</p>\n<pre><code>var div2 = document.getElementById(&quot;div2&quot;);\nvar attr = div2.getAttribute(&quot;class&quot;);\nconsole.log(attr);\n</code></pre>\n<p>注意：IE7下不能正确返回class，返回的是null，其他正常。</p>\n<p>hasAttribute()</p>\n<p>hasAttribute() 返回一个布尔值，指示该元素是否包含有指定的属性（attribute）。</p>\n<p>注意：IE7不支持该方法。</p>\n<p>自定义属性data-*</p>\n<p>html5里有一个data-*去设置获取元素的自定义属性值。</p>\n<div id=\"div1\" data-aa=\"11\"> 利用div1.dataset可以获得一个DOMStringMap，包含了元素的所有data-*。 使用div1.dataset.aa就可以获取11的值。 同样，通过设置div1.dataset.bb = \"22\"就可以设置一个自定义属性值。 在不兼容的浏览器里，就使用getAttribute和setAttribute\n<pre><code>var div1 = document.getElementById(&quot;div1&quot;);\nvar a = null;\nif (div1.dataset) {\n    a = div1.dataset.aa;\n    div1.dataset.bb = &quot;222&quot;;\n} else {\n    a = div1.getAttribute(&quot;data-aa&quot;);\n    div1.setAttribute(&quot;data-bb&quot;, &quot;2222&quot;);\n}\nconsole.log(a);\n</code></pre>\n<p>mipsasm\n7.事件\naddEventListener()</p>\n<p>addEventListener()将指定的事件监听器注册到目标对象上，当目标对象触发制定的事件时，指定的回调函数就会触发。目标对象可以是 文档上的元素、 document、 window 或者XMLHttpRequest(比如onreadystatechange事件)。</p>\n<p>IE8及以下不支持此方法且只有事件冒泡没有事件捕获。IE9开始支持此方法，也就有了事件捕获。</p>\n<pre><code>var div1 = document.getElementById(&quot;div1&quot;);\ndiv1.addEventListener(&quot;click&quot;, listener, false);\nfunction listener() {\n    console.log(\'test\');\n}\nvar cloneHtml = div1.cloneNode(true);\ndocument.body.appendChild(cloneHtml);\n</code></pre>\n<p>javascript\n第一个参数是事件名，第二个是回调函数，第三个参数为true表示捕获，false表示冒泡。</p>\n<pre><code>var div1 = document.getElementById(&quot;div1&quot;);\ndiv1.addEventListener(&quot;click&quot;, listener1, true/fasle);\nfunction listener1() {\n    console.log(\'test1\');\n}\nvar div2 = document.getElementById(&quot;div2&quot;);\ndiv2.addEventListener(&quot;click&quot;, listener2, true/fasle);\nfunction listener2() {\n    console.log(\'test2\');\n}\n</code></pre>\n<p>javascript\n有一点要注意的是，当对某一个元素1既绑定了捕获事件，又绑定了冒泡事件时： 当这个元素1并不是触发事件的那个元素2时，则触发顺序会按照先 捕获 后 冒泡 的顺序触发； 当这个元素1就是最底层的触发事件的元素时，则这个元素没有捕获和冒泡的区别，谁先绑定就先触发谁。</p>\n<p>var div2 = document.getElementById(“div2”);\ndiv2.addEventListener(“click”, listener2, true);\nfunction listener2() {\nconsole.log(‘test2’);\n}\ndiv2.addEventListener(“click”, listener1, false);\nfunction listener1() {\nconsole.log(‘test1’);\n}\n// 按绑定顺序执行，两个<code>addEventLister()</code>颠倒过来则执行顺序也变化\n// 如果再对<code>div1</code>绑定一个捕获、一个冒泡，则会先触发捕获 再 触发冒泡，与绑定顺序无关\njavascript\nremoveEventListener()</p>\n<p>与addEventListener()绑定事件对应的就是移除已绑定的事件。第三个参数的布尔值代表解绑的是捕获事件还是冒泡事件。两个事件互不相关。</p>\n<pre><code>var div2 = document.getElementById(&quot;div2&quot;); \ndiv2.addEventListener(&quot;click&quot;, listener2, true);\nfunction listener2() {\n    console.log(\'test2\');\n}\ndiv2.removeEventListener(&quot;click&quot;, listener2, true);\n</code></pre>\n<p>javascript\n注意：只能通过removeEventListener()解绑有名字的函数，对于绑定的匿名函数无法解除绑定。</p>\n<p>div2.addEventListener(“click”, function(){\nconsole.log(‘test’);\nconsole.log(this);\n}, true);\ndiv2.removeEventListener(“click”, function() {\nconsole.log(“test”);\n}, true);\ndiv2.onclick = null;\n// 点击div2依然打印出test\njavascript\n注意：这里this指向触发事件的元素自身。</p>\n<p>attachEvent()、detachEvent()</p>\n<p>IE8及以下使用这两个方法绑定和解绑事件，当然，IE9+也支持这个事件。但这个方法绑定的事件默认为冒泡也只有冒泡。</p>\n<pre><code>// 这里需要在事件前加 on\ndiv2.attachEvent(&quot;onclick&quot;, listener1);\nfunction listener1() {\n    console.log(\'test\');\n    console.log(this);\n}\ndiv2.detachEvent(&quot;onclick&quot;, listener1);\n</code></pre>\n<p>javascript\n和addEventListener()一样，也不能解绑匿名函数。 注意：这里this指向 window。</p>\n<p>阻止默认事件和冒泡 标准事件和IE事件中的阻止默认事件和冒泡事件也有很大区别。</p>\n<p>var div2 = document.getElementById(“div2”);\nif (div2.addEventListener) {\ndiv2.addEventListener(“click”, function(e) {\ne.preventDefault(); // 阻止默认事件\ne.stopPropagation(); // 阻止冒泡\nconsole.log(e.target.innerHTML);\n}, false);\n} else {\ndiv2.attachEvent(“onclick”, function() {\nvar e = window.event;\ne.returnValue = false; // 阻止默认事件\ne.cancelBubble = true; // 阻止冒泡\nconsole.log(e.srcElement.innerHTML);\n});\n}\njavascript\nIE8及以下的event是绑定在window上的。（我的IE11里，仿真到IE7、IE8也可以取到标准事件里的 e 对象，估计是升级到IE11的原因）。</p>\n<p>自定义事件：createEvent()</p>\n<p>createEvent()用于创建一个新的 event ，而后这个 event 必须调用它的 init() 方法进行初始化。最后就可以在目标元素上使用dispatchEvent()调用新创建的event事件了。</p>\n<p>createEvent()的参数一般有：UIEvents、MouseEvents、MutationEvents、HTMLEvents、Event(s)等等，分别有对应的init()方法。HTMLEvents、Event(s)对应的都是initEvent()方法。</p>\n<p>initEvent(type, bubbles, cancelable)</p>\n<p>type表示自定义的事件类型，bubbles表示是否冒泡，cancelable表示是否阻止默认事件。</p>\n<p>target.dispatchEvent(ev) target就是要触发自定义事件的DOM元素</p>\n<pre><code>    var div1 = document.getElementById(&quot;div1&quot;);\n    div1.addEventListener(&quot;message&quot;, function(){\n        console.log(\'test\');\n    }, false);\n    var div2 = document.getElementById(&quot;div2&quot;);\n    div2.addEventListener(&quot;message&quot;, function(e){\n        console.log(this);\n        console.log(e);\n    }, false);\n    var ev = document.createEvent(&quot;Event&quot;);\n    ev.initEvent(&quot;message&quot;, false, true); // 起泡参数变为true，div1的事件就会触发\n    div2.dispatchEvent(ev);\n</code></pre>\n<p>javascript\n8.获取元素相关计算后的值\ngetComputedStyle()、currentStyle()</p>\n<p>当我们想获取元素计算后实际呈现在页面上的各个值，就用这两个方法。IE8及以下用currentStyle(),IE9+及其他标准浏览器用getComputedStyle()。</p>\n<pre><code>var div2 = document.getElementById(&quot;div2&quot;);\nvar result = &quot;&quot;;\nif (window.getComputedStyle) {\n    result = (window || document.defaultView).getComputedStyle(div2, null)[\'cssFloat\'];\n} else {\n    result = div2.currentStyle[&quot;styleFloat&quot;];\n}\nconsole.log(result);\n// document.defaultView返回document对象所关联的window\n</code></pre>\n<p>coffeescript\n注意：这两个方法在不同的浏览器里差距也很大。 比如float属性： getComputedStyle： IE9以上需要用cssFloat，其他标准的用float currentStyle： IE8及以下可用styleFloat或者float。</p>\n<p>比如height属性： 假如未设置height值，标准浏览器里能计算出高度值，而currentStyle计算出来是auto。</p>\n<p>上面的例子getComputedStyle是用键值去访问的，也可用getPropertyValue()去访问。（IE8、IE7不支持）</p>\n<p>result = (window || document.defaultView).getComputedStyle(div2, null).getPropertyValue(“float”);</p>\n<p>getBoundingClientRect()、getClientRects()</p>\n<p>getBoundingClientRect()该方法获得页面中某个元素的上、右、下、左分别相对浏览器视窗的位置。getBoundingClientRect是DOM元素到浏览器可视范围的距离（到浏览器顶部而不是文档顶部）。该函数返回一个Object对象，该对象有6个属性：top,lef,right,bottom,width,height；这里的top、left和css中的理解很相似，width、height是元素自身的宽高，但是right，bottom和css中的理解有点不一样。right是指元素右边界距窗口最左边的距离，bottom是指元素下边界距窗口最上面的距离。</p>\n<p>getClientRects()是返回一个ClientRectList集合。</p>\n<pre><code>var div1 = document.getElementById(&quot;div1&quot;);\nvar rects1 = div1.getClientRects();\nvar rects2 = div1.getBoundingClientRect();\nconsole.log(rects1[0].top);\nconsole.log(rects2.top);</code></pre>\n', 'images/1_marble_xu_1550829754.jpg', '', '8', '0', '');

-- ----------------------------
-- Table structure for comments
-- ----------------------------
DROP TABLE IF EXISTS `comments`;
CREATE TABLE `comments` (
  `id` varchar(255) NOT NULL,
  `author_id` varchar(255) DEFAULT NULL,
  `datetime` varchar(255) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of comments
-- ----------------------------
INSERT INTO `comments` VALUES ('20190928135419', '1', '2019-10-13 15:54:09', '打发');
INSERT INTO `comments` VALUES ('20190928135419', '1', '2019-10-13 16:05:02', '是打发斯蒂芬的');
INSERT INTO `comments` VALUES ('20190928135419', '8', '2019-10-13 16:26:30', '12');
INSERT INTO `comments` VALUES ('20190928135419', '1', '2019-10-13 16:29:57', '奥数');
INSERT INTO `comments` VALUES ('20190928135419', '8', '2019-10-13 16:30:42', '手动阀');
INSERT INTO `comments` VALUES ('20190928135419', '8', '2019-10-13 16:31:39', '撒旦法');
INSERT INTO `comments` VALUES ('20190928135419', '1', '2019-10-13 16:52:39', '是的发送到');
INSERT INTO `comments` VALUES ('20190928155526', '1', '2019-10-13 17:57:54', 'test');
INSERT INTO `comments` VALUES ('20190928155526', '1', '2019-10-15 10:57:23', '打开了房间爱迪生');
INSERT INTO `comments` VALUES ('20191017173856', '1', '2019-10-18 19:26:50', 'test');
INSERT INTO `comments` VALUES ('20190602150347', '1', '2019-10-18 19:27:00', 'test');
INSERT INTO `comments` VALUES ('20190602150347', '8', '2019-10-19 21:05:00', '12313');
INSERT INTO `comments` VALUES ('20190602150347', '1', '2019-10-19 21:10:50', '00');
INSERT INTO `comments` VALUES ('20191022094216', '09.32.17am', '2019-10-22 09:46:44', 'sdfasda ');
INSERT INTO `comments` VALUES ('1574218871', '8', '2019-11-23 08:51:49.219733', '阿士大夫撒旦');
INSERT INTO `comments` VALUES ('1574218871', '8', '2019-11-23 09:27:26.899764', '距离看见了看见了');
INSERT INTO `comments` VALUES ('1574218871', '8', '2019-11-23 20:33:01', '重中之重');
INSERT INTO `comments` VALUES ('1574218944', '8', '2019-11-23 20:35:50', 'test');
INSERT INTO `comments` VALUES ('1574218871', '8', '2019-12-11 14:12:18', 'F方法是');

-- ----------------------------
-- Table structure for info
-- ----------------------------
DROP TABLE IF EXISTS `info`;
CREATE TABLE `info` (
  `id` varchar(255) NOT NULL,
  `username` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `school` varchar(255) DEFAULT NULL,
  `userimages` varchar(255) DEFAULT NULL,
  `likes` varchar(255) NOT NULL,
  `collects` varchar(255) NOT NULL,
  `follows` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of info
-- ----------------------------
INSERT INTO `info` VALUES ('1', '小负子', 'xfz123456', '西华师范大学', 'C:\\Users\\xiaofuzi\\PhpstormProjects//slim3\\/public/images/0b7061bcf2f05ea41f8649938362286df9cd3dc7d437-GvxzBF_fw658.jpg', 'article=20190928155526|video=20190602150347|1574218871|', 'article=20190928155526|article=20190928163836|video=20190602150347|article=20191017173923|1574218871|', '');
INSERT INTO `info` VALUES ('2', '小负子1', 'xfz123456', null, 'C:\\Users\\xiaofuzi\\PhpstormProjects//slim3\\/public/images/0b7061bcf2f05ea41f8649938362286df9cd3dc7d437-GvxzBF_fw658.jpg', '', '', '');
INSERT INTO `info` VALUES ('3', '小负子', 'xfz123456', null, 'C:\\Users\\xiaofuzi\\PhpstormProjects//slim3\\/public/images/0b7061bcf2f05ea41f8649938362286df9cd3dc7d437-GvxzBF_fw658.jpg', '', '', '');
INSERT INTO `info` VALUES ('4', '盛大发售', 'asddas', null, null, '', '', '');
INSERT INTO `info` VALUES ('5', '是打发', 'asdds', null, null, '', '', '');
INSERT INTO `info` VALUES ('6', '啊是的范德萨', 'dsafas', null, null, '', '', '');
INSERT INTO `info` VALUES ('7', '大厦法定', 'asdfasdd ', null, null, '', '', '');
INSERT INTO `info` VALUES ('8', 'test', '123456', '西华师范大学', 'avator/1b3094dc1746bd302845e1576193a8a03232f7db9f89a-CBB7i0_fw658.jpg', '1574218871|1574218944|1574218944|1574322585|1574328704|1574322596|1574238492|', '1574218871|1574218944|1574218944|1574328704|', '');
INSERT INTO `info` VALUES ('9', '小负子', 'xfz123456', null, 'C:\\Users\\xiaofuzi\\PhpstormProjects//slim3\\/public/images/0b7061bcf2f05ea41f8649938362286df9cd3dc7d437-GvxzBF_fw658.jpg', '', '', '');
INSERT INTO `info` VALUES ('10', '士大夫撒', 'adas', null, null, '', '', '');
INSERT INTO `info` VALUES ('11', '都是发生大', 'sss', '阿斯顿发士大夫sad', null, '', '', '');
INSERT INTO `info` VALUES ('09.14.38am', 'zzz', 'zzz', 'xihu', 'C:\\Users\\xiaofuzi\\PhpstormProjects//slim3\\/public/images/1b3094dc1746bd302845e1576193a8a03232f7db9f89a-CBB7i0_fw658.jpg', '', '', '');
INSERT INTO `info` VALUES ('09.32.17am', 'abc', 'abc', 'xihu', 'C:\\Users\\xiaofuzi\\PhpstormProjects//slim3\\/public/images/1d73043e6c1bb04bdc3f037f26c509988e68039b567a7-3mwJJi_fw658.jpg', '', '', '');
INSERT INTO `info` VALUES ('1574162822', 'sdfsdfs', '1231', 'asdfsdfs', 'avator/demo.jpg', '', '', '');
INSERT INTO `info` VALUES ('1576133303', 'xfz', '123', 'xihu', 'avator/demo.jpg', '', '', '');
